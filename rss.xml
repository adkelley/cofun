<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Cofun with cofree comonads</title>
        <link>http://dlaing.org/cofun</link>
        <description><![CDATA[]]></description>
        <atom:link href="http://dlaing.org/cofun/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Mon, 07 Sep 2015 02:00:00 UT</lastBuildDate>
        <item>
    <title>Pairing over the network</title>
    <link>http://dlaing.org/cofun/posts/pairing_over_the_network.html</link>
    <description><![CDATA[<h1 id="the-goal">The goal</h1>
<p>This is part of an ongoing series of posts about <a href="../">fun with Cofree Comonads</a>. If you’re just jumping in, I’d recommend reading the series from the start, since this post assumes that you’re up to date.</p>
<p>For this post I want to focus on establishing a pairing between a <code>Free</code>-based DSL with a <code>Cofree</code>-based interpreter over the network.</p>
<p>This is all meant to be illustrative. I won’t be spending any time on getting the asynchronous exceptions or the binary streaming to anything beyond a toy level, although I may double back at a later date and take care of that.</p>
<p>Coproducts and products will take a back seat for a post or two, although they’ll return as soon as we have described all of the pieces we need.</p>
<h1 id="two-approaches">Two approaches</h1>
<p>Recall that we had a type <code>AdderF</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AdderF</span> k <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">Int</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> k)
              <span class="fu">|</span> <span class="dt">Clear</span> k
              <span class="fu">|</span> <span class="dt">Total</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> k)</code></pre></div>
<p>and a type <code>CoAdderF</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoAdderF</span> k <span class="fu">=</span> <span class="dt">CoAdderF</span> {
<span class="ot">    addH   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, k)
  ,<span class="ot"> clearH ::</span> k
  ,<span class="ot"> totalH ::</span> (<span class="dt">Int</span>, k)
  }</code></pre></div>
<p>In earlier posts, we have discussed that we can view each of the constructors <code>Add</code>, <code>Clear</code> and <code>Total</code> as being comprised of a set of input parameters and a function from output parameters to <code>k</code>.</p>
<p>If we view our <code>Free AdderF</code> as a protocol, we can view these as requests and responses. Considering our goal is to establish a pairing over the network, this seems like a good avenue to explore.</p>
<p>To formalize the protocol / request / response notion somewhat, if we had</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Client</span> req res k <span class="fu">=</span> (req, res <span class="ot">-&gt;</span> k)</code></pre></div>
<p>we could recast <code>AdderF</code> as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AdderF</span> k <span class="fu">=</span> <span class="dt">Add</span>   (<span class="dt">Client</span> <span class="dt">Int</span> <span class="dt">Bool</span> k)
              <span class="fu">|</span> <span class="dt">Clear</span> (<span class="dt">Client</span> () () k)
              <span class="fu">|</span> <span class="dt">Total</span> (<span class="dt">Client</span> () <span class="dt">Int</span> k)</code></pre></div>
<p>and with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Interpreter</span> req res k <span class="fu">=</span> req <span class="ot">-&gt;</span> (res, k)</code></pre></div>
<p>we could recast <code>CoAdderF</code> as</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoAdderF</span> k <span class="fu">=</span> <span class="dt">CoAdderF</span> {
<span class="ot">    addH   ::</span> <span class="dt">Interpreter</span> <span class="dt">Int</span> <span class="dt">Bool</span> k
  ,<span class="ot"> clearH ::</span> <span class="dt">Interpreter</span> () () k
  ,<span class="ot"> totalH ::</span> <span class="dt">Interpreter</span> () <span class="dt">Int</span> k
  }</code></pre></div>
<p>We can turn this “inside out” if we define</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AdderReq</span> <span class="fu">=</span> <span class="dt">AddReq</span> <span class="dt">Int</span>
              <span class="fu">|</span> <span class="dt">ClearReq</span>
              <span class="fu">|</span> <span class="dt">TotalReq</span></code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AdderRes</span> <span class="fu">=</span> <span class="dt">AddRes</span> <span class="dt">Bool</span>
              <span class="fu">|</span> <span class="dt">ClearRes</span>
              <span class="fu">|</span> <span class="dt">TotalRes</span> <span class="dt">Int</span></code></pre></div>
<p>from which we can get</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">AdderF</span> k <span class="fu">=</span> <span class="dt">Client</span> <span class="dt">AdderReq</span> <span class="dt">AdderRes</span> k</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CoAdderF</span> k <span class="fu">=</span> <span class="dt">Interpreter</span> <span class="dt">AdderReq</span> <span class="dt">AdderRes</span> k</code></pre></div>
<p>Regardless of which approach we take, we’re going to need:</p>
<ul>
<li>pairings between the DSL and the interpreter</li>
<li>serialization of our requests and responses</li>
<li>the ability to handle errors and IO</li>
</ul>
<p>The first approach is going to require a serialization strategy where none of the coproducts contributing to <code>AdderF</code> will get in each others way. We’ll return to that once we’ve covered some of the associated type-level machinery in the next post.</p>
<p>The second approach has some risk of mismatching requests and responses while they are in flight. Since we need to handle errors anyway, we just need to make sure that our methods of error handling is sufficient to deal with mismatched requests and responses and all should be well.</p>
<h1 id="the-intermediate-stage">The intermediate stage</h1>
<p>Since we’re going to handle effects when we take to the network, lets weave some effects into our client and interpreter types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NetworkClientF</span> req res m k <span class="fu">=</span> <span class="dt">NetworkClientF</span> (req, res <span class="ot">-&gt;</span> m k)

<span class="kw">data</span> <span class="dt">NetworkInterpreterF</span> req res m k <span class="fu">=</span> <span class="dt">NetworkInterpreterF</span> (req <span class="ot">-&gt;</span> m (res, k))</code></pre></div>
<p>We also want these to be <code>Functor</code>s, so that we can pair them:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">NetworkClientF</span> req res m)  <span class="kw">where</span>
  fmap f (<span class="dt">NetworkClientF</span> k) <span class="fu">=</span> <span class="dt">NetworkClientF</span> (fmap (fmap (fmap f)) k)

<span class="kw">instance</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">NetworkInterpreterF</span> req res m) <span class="kw">where</span>
  fmap f (<span class="dt">NetworkInterpreterF</span> k) <span class="fu">=</span> <span class="dt">NetworkInterpreterF</span> (fmap (fmap (fmap f)) k)</code></pre></div>
<p>The problem we have now is that <code>Pairing</code> doesn’t know about effects:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Pairing</span> f g <span class="fu">|</span> f <span class="ot">-&gt;</span> g, g <span class="ot">-&gt;</span> f <span class="kw">where</span>
<span class="ot">  pair ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> r</code></pre></div>
<p>We deal with this in the usual manner - if we need effects, add an <code>m</code> somewhere:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">PairingM</span> f g m <span class="fu">|</span> f <span class="ot">-&gt;</span> g, g <span class="ot">-&gt;</span> f <span class="kw">where</span>
<span class="ot">  pairM ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> m r</code></pre></div>
<p>(although this was actually concocted in a slightly less ad-hoc manner than just adding an <code>m</code> and hoping).</p>
<p>Now we have what we need to link the client and interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">PairingM</span> (<span class="dt">NetworkInterpreterF</span> req res m) (<span class="dt">NetworkClientF</span> req res m) m <span class="kw">where</span>
  pairM p (<span class="dt">NetworkInterpreterF</span> fi) (<span class="dt">NetworkClientF</span> (rq, fc)) <span class="fu">=</span> <span class="kw">do</span>
    (rs, ki) <span class="ot">&lt;-</span> fi rq
    kc <span class="ot">&lt;-</span> fc rs
    p ki kc</code></pre></div>
<p>given some way to actually make use of the <code>PairingM</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffectM ::</span> ( <span class="dt">Functor</span> (f m)
               , <span class="dt">PairingM</span> (f m) (g m) m
               , <span class="dt">Comonad</span> w
               , <span class="dt">Monad</span> m
               )
            <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> m r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> (f m) w (m a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> (g m) m b <span class="ot">-&gt;</span> m r
pairEffectM p s c <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> extract s
  mb <span class="ot">&lt;-</span> runFreeT c
  <span class="kw">case</span> mb <span class="kw">of</span>
    <span class="dt">Pure</span> x <span class="ot">-&gt;</span> p a x
    <span class="dt">Free</span> gs <span class="ot">-&gt;</span> pairM (pairEffectM p) (unwrap s) gs</code></pre></div>
<p>This is where we need to get to as a first step to connecting our DSL and interpreter over the network.</p>
<h1 id="getting-from-the-beginning-to-the-middle">Getting from the beginning to the middle</h1>
<p>Our previous console example was</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect (\_ r <span class="ot">-&gt;</span> r) (mkCoAdderWithLogging <span class="dv">10</span> <span class="dv">0</span>) runConsole</code></pre></div>
<p>which connects an interactive console with an interpreter which prints information about what it is up to.</p>
<p>This made use of</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runConsole ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadIO</span> m, <span class="dt">ConsoleClient</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> f m ()</code></pre></div>
<p>and the instance of <code>ConsoleClient</code> for <code>AdderF</code>, along with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdderWithLogging ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> <span class="dt">CoAdderF</span> (<span class="dt">StoreT</span> <span class="dt">Int</span> (<span class="dt">EnvT</span> <span class="dt">Int</span> <span class="dt">Identity</span>)) (m ())</code></pre></div>
<p>Our goal is to get the same functionality working across the network.</p>
<p>What we have so far has the form <code>FreeT AdderF m a</code> or <code>CofreeT CoAdderF w a</code>, and we need to get it into a form that uses <code>NetworkClientF</code> or <code>NetworkInterpreterF</code>.</p>
<p>There are some useful helper functions for working with <code>FreeT</code> in the <code>Control.Monad.Trans.Free</code> module of the <code>free</code> package.</p>
<p>Amongst them are</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">transFreeT ::</span> (<span class="dt">Monad</span> m, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> (forall a<span class="fu">.</span> f a <span class="ot">-&gt;</span> g a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> f m b <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b </code></pre></div>
<p>which lets us swap out the underlying <code>Functor</code>, and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hoistFreeT ::</span> (<span class="dt">Monad</span> m, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> f m b <span class="ot">-&gt;</span> <span class="dt">FreeT</span> f n b</code></pre></div>
<p>which lets us swap out (or transform) the underlying <code>Monad</code>.</p>
<p>There are also some very handy tools we can use in conjunction with <code>hoistFreeT</code> in the <a href="http://hackage.haskell.org/package/mmorph">mmorph</a> package.</p>
<p>For cofree, there are instances of <code>ComonadHoist</code> throughout the <code>free</code> package which will give us hoisting, and the <code>master</code> branch on github has</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">transCofreeT ::</span> (<span class="dt">Comonad</span> w, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> (forall a<span class="fu">.</span> f a <span class="ot">-&gt;</span> g a) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w b <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> g w b </code></pre></div>
<p>if you’re feeling adventurous and want to play along.</p>
<p>As an aside: ordinarily I’d try to use <code>transFreeT</code> and <code>hoistFreeT</code> to try to get by with a regular <code>Pairing</code> instance rather than a <code>PairingM</code> instance. I tried a few variants to make that work, but struggled with some of the details of getting the error handling interleaved with the pairing in the correct fashion. I’ll be trying again later on, but if anyone happens to play around with this and finds a way to do without <code>PairingM</code>, please get in touch and let me know.</p>
<p>We’re usually working with <code>FreeT AdderF m a</code> and we’d like to get that to <code>FreeT (NetworkClientF AdderReq AdderRes m) m a</code>, so it seems like <code>transFreeT</code> is just what we want. Now we need a function to transform <code>AdderF k</code> into <code>NetworkClientF AdderReq AdderRes m k</code> and a function to transform <code>CoAdderF k</code> into <code>NetworkInterpreterF AdderReq AdderRes m k</code>.</p>
<p>With that in mind - and realizing that we may want to use some of this machinery for more than this single toy example - we set up the type families:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ToNetworkClient</span> (<span class="ot">a ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) m <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ClientReq</span> a
  <span class="kw">type</span> <span class="dt">ClientRes</span> a
<span class="ot">  toNetworkClient ::</span> a k <span class="ot">-&gt;</span> <span class="dt">NetworkClientF</span> (<span class="dt">ClientReq</span> a) (<span class="dt">ClientRes</span> a) m k

<span class="kw">class</span> <span class="dt">ToNetworkInterpreter</span> (<span class="ot">a ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) m <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">InterpreterReq</span> a
  <span class="kw">type</span> <span class="dt">InterpreterRes</span> a
<span class="ot">  toNetworkInterpreter ::</span> a k <span class="ot">-&gt;</span> <span class="dt">NetworkInterpreterF</span> (<span class="dt">InterpreterReq</span> a) (<span class="dt">InterpreterRes</span> a) m k</code></pre></div>
<p>to assist us.</p>
<p>The translation for <code>AdderF</code> makes use of our network error type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">NetError</span> <span class="fu">=</span> <span class="dt">Disconnected</span>
              <span class="fu">|</span> <span class="dt">UnexpectedRequest</span>
              <span class="fu">|</span> <span class="dt">UnexpectedResponse</span></code></pre></div>
<p>and introduces a <code>MonadError NetError m</code> constraint from the <code>Control.Monad.Except</code> module in the <code>mtl</code> package:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monad</span> m, <span class="dt">MonadError</span> <span class="dt">NetError</span> m) <span class="ot">=&gt;</span> <span class="dt">ToNetworkClient</span> <span class="dt">AdderF</span> m <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">ClientReq</span> <span class="dt">AdderF</span> <span class="fu">=</span> <span class="dt">AdderReq</span>
  <span class="kw">type</span> <span class="dt">ClientRes</span> <span class="dt">AdderF</span> <span class="fu">=</span> <span class="dt">AdderRes</span>

  toNetworkClient (<span class="dt">Add</span> x f) <span class="fu">=</span> <span class="dt">NetworkClientF</span> (<span class="dt">AddReq</span> x, g)
    <span class="kw">where</span>
      g (<span class="dt">AddRes</span> b) <span class="fu">=</span> return <span class="fu">$</span> f b
      g _ <span class="fu">=</span> throwError <span class="dt">UnexpectedResponse</span>

  toNetworkClient (<span class="dt">Clear</span> k) <span class="fu">=</span> <span class="dt">NetworkClientF</span> (<span class="dt">ClearReq</span>, g)
    <span class="kw">where</span>
      g <span class="dt">ClearRes</span> <span class="fu">=</span> return k
      g _ <span class="fu">=</span> throwError <span class="dt">UnexpectedResponse</span>

  toNetworkClient (<span class="dt">Total</span> f) <span class="fu">=</span> <span class="dt">NetworkClientF</span> (<span class="dt">TotalReq</span>, g)
    <span class="kw">where</span>
      g (<span class="dt">TotalRes</span> i) <span class="fu">=</span> return <span class="fu">$</span> f i
      g _ <span class="fu">=</span> throwError <span class="dt">UnexpectedResponse</span></code></pre></div>
<p>The translation for <code>CoAdderF</code> involves less drama:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ToNetworkInterpreter</span> <span class="dt">CoAdderF</span> m <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">InterpreterReq</span> <span class="dt">CoAdderF</span> <span class="fu">=</span> <span class="dt">AdderReq</span>
  <span class="kw">type</span> <span class="dt">InterpreterRes</span> <span class="dt">CoAdderF</span> <span class="fu">=</span> <span class="dt">AdderRes</span>

  toNetworkInterpreter (<span class="dt">CoAdderF</span> a c t) <span class="fu">=</span> <span class="dt">NetworkInterpreterF</span> <span class="fu">$</span> \rq <span class="ot">-&gt;</span> <span class="kw">case</span> rq <span class="kw">of</span>
      <span class="dt">AddReq</span> i <span class="ot">-&gt;</span> <span class="kw">let</span>
                    (b, k) <span class="fu">=</span> a i
                  <span class="kw">in</span> return (<span class="dt">AddRes</span> b, k)
      <span class="dt">ClearReq</span> <span class="ot">-&gt;</span> return (<span class="dt">ClearRes</span>, c)
      <span class="dt">TotalReq</span> <span class="ot">-&gt;</span> <span class="kw">let</span>
                    (i, k) <span class="fu">=</span> t
                  <span class="kw">in</span> return (<span class="dt">TotalRes</span> i, k)</code></pre></div>
<p>At this point we can recast our DSLs and interpreters into a more network-friendly form, but we still need to connect them up to the network.</p>
<h1 id="getting-from-the-middle-to-the-end">Getting from the middle to the end</h1>
<h2 id="the-client-side">The client side</h2>
<p>From the client side, we want to translate our <code>FreeT c m a</code> to a <code>FreeT (NetworkClientF (ClientReq c) (ClientRes c) m) m a</code>, and then pair it with something to connect it with the network.</p>
<p>We want something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairClient ::</span> ( <span class="dt">Functor</span> m
              , <span class="dt">MonadError</span> <span class="dt">NetError</span> m
              , <span class="dt">ToNetworkClient</span> c m
              )
           <span class="ot">=&gt;</span> <span class="dt">FreeT</span> c m () <span class="ot">-&gt;</span> m ()
pairClient <span class="fu">=</span> pairEffectM (\_ r <span class="ot">-&gt;</span> return r) <span class="fu">???</span> <span class="fu">.</span> transFreeT toNetworkClient</code></pre></div>
<p>and from the pairing we already have, we can reasonably assume that <code>???</code> is going to be some kind of <code>CofreeT (NetworkInterpreterF (InterpreterReq c) (InterpreterRes c) m) w a</code></p>
<p>Making use of the <code>network-simple</code> package and assuming that we’ve already got access to a connected <code>Socket</code>, we can devise something like that:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkClientConnector ::</span> ( <span class="dt">Functor</span> m
                     , <span class="dt">MonadReader</span> <span class="dt">Socket</span> m
                     , <span class="dt">MonadError</span> <span class="dt">NetError</span> m
                     , <span class="dt">MonadIO</span> m
                     , <span class="dt">Binary</span> req
                     , <span class="dt">Binary</span> res
                     )
                  <span class="ot">=&gt;</span> <span class="dt">Cofree</span> (<span class="dt">NetworkInterpreterF</span> req res m) (m ())
mkClientConnector <span class="fu">=</span> coiterT f (<span class="dt">Identity</span> (return ()))
  <span class="kw">where</span>
    f w <span class="fu">=</span> <span class="dt">NetworkInterpreterF</span> <span class="fu">$</span> \req <span class="ot">-&gt;</span> <span class="kw">do</span>
      <span class="co">-- get the socket</span>
      s <span class="ot">&lt;-</span> ask
      <span class="co">-- encode and send the request</span>
      send s <span class="fu">.</span> L.toStrict <span class="fu">.</span> encode <span class="fu">$</span> req
      <span class="co">-- read and decode the response</span>
      res <span class="ot">&lt;-</span> fmap (decode <span class="fu">.</span> L.fromStrict) <span class="fu">&lt;$&gt;</span> recv s <span class="dv">1024</span>
      <span class="co">-- check for disconnection</span>
      <span class="kw">case</span> res <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwError <span class="dt">Disconnected</span>
        <span class="dt">Just</span> x <span class="ot">-&gt;</span> return (x, w)</code></pre></div>
<p>This is where we end up needing <code>Binary</code> instances for <code>AdderReq</code> and <code>AdderRes</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Binary</span> <span class="dt">AdderReq</span> <span class="kw">where</span>
  put (<span class="dt">AddReq</span> i) <span class="fu">=</span> putWord8 <span class="dv">0</span> <span class="fu">&gt;&gt;</span> put i
  put <span class="dt">ClearReq</span> <span class="fu">=</span> putWord8 <span class="dv">1</span>
  put <span class="dt">TotalReq</span> <span class="fu">=</span> putWord8 <span class="dv">2</span>

  get <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> getWord8
    <span class="kw">case</span> x <span class="kw">of</span>
      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">AddReq</span> <span class="fu">&lt;$&gt;</span> get
      <span class="dv">1</span> <span class="ot">-&gt;</span> return <span class="dt">ClearReq</span>
      <span class="dv">2</span> <span class="ot">-&gt;</span> return <span class="dt">TotalReq</span>
      _ <span class="ot">-&gt;</span> empty

<span class="kw">instance</span> <span class="dt">Binary</span> <span class="dt">AdderRes</span> <span class="kw">where</span>
  put (<span class="dt">AddRes</span> b) <span class="fu">=</span> putWord8 <span class="dv">0</span> <span class="fu">&gt;&gt;</span> put b
  put <span class="dt">ClearRes</span> <span class="fu">=</span> putWord8 <span class="dv">1</span>
  put (<span class="dt">TotalRes</span> i) <span class="fu">=</span> putWord8 <span class="dv">2</span> <span class="fu">&gt;&gt;</span> put i

  get <span class="fu">=</span> <span class="kw">do</span>
    x <span class="ot">&lt;-</span> getWord8
    <span class="kw">case</span> x <span class="kw">of</span>
      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">AddRes</span> <span class="fu">&lt;$&gt;</span> get
      <span class="dv">1</span> <span class="ot">-&gt;</span> return <span class="dt">ClearRes</span>
      <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dt">TotalRes</span> <span class="fu">&lt;$&gt;</span> get
      _ <span class="ot">-&gt;</span> empty</code></pre></div>
<p>With that in hand, we can update <code>pairClient</code> to make use of <code>mkClientConnector</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairClient ::</span> ( <span class="dt">Functor</span> m
              , <span class="dt">MonadReader</span> <span class="dt">Socket</span> m
              , <span class="dt">MonadError</span> <span class="dt">NetError</span> m
              , <span class="dt">MonadIO</span> m
              , <span class="dt">ToNetworkClient</span> c m
              , <span class="dt">Binary</span> (<span class="dt">ClientReq</span> c)
              , <span class="dt">Binary</span> (<span class="dt">ClientRes</span> c)
              )
           <span class="ot">=&gt;</span> <span class="dt">FreeT</span> c m () <span class="ot">-&gt;</span> m ()
pairClient <span class="fu">=</span> pairEffectM (\_ r <span class="ot">-&gt;</span> return r) mkClientConnector <span class="fu">.</span> transFreeT toNetworkClient</code></pre></div>
<p>We add a helper function to connect the socket and handle the <code>MonadReader Socket</code> and <code>MonadError NetError</code> obligations:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runClient ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadMask</span> m) <span class="ot">=&gt;</span> <span class="dt">HostName</span> <span class="ot">-&gt;</span> <span class="dt">ServiceName</span> <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Socket</span> (<span class="dt">ExceptT</span> <span class="dt">NetError</span> m) a <span class="ot">-&gt;</span> m (<span class="dt">Either</span> <span class="dt">NetError</span> a)
runClient host service x <span class="fu">=</span> connect host service <span class="fu">$</span> \(sock, _) <span class="ot">-&gt;</span> runExceptT <span class="fu">.</span> flip runReaderT sock <span class="fu">$</span> x</code></pre></div>
<p>With all of this in hand, we can finally connect our <code>runConsole</code> function to the network:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkClient ::</span> <span class="dt">HostName</span> <span class="ot">-&gt;</span> <span class="dt">ServiceName</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">NetError</span> ())
networkClient host service <span class="fu">=</span> runClient host service (pairClient console)
  <span class="kw">where</span>
    console <span class="fu">=</span><span class="ot"> runConsole ::</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> (<span class="dt">ReaderT</span> <span class="dt">Socket</span> (<span class="dt">ExceptT</span> <span class="dt">NetError</span> <span class="dt">IO</span>)) ()</code></pre></div>
<h2 id="the-interpreter-side">The interpreter side</h2>
<p>We end up with similar pieces of functionality to get the interpreter connected to the network.</p>
<p>We have the pairing function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairInterpreter ::</span> ( <span class="dt">Functor</span> m
                   , <span class="dt">Comonad</span> w
                   , <span class="dt">MonadReader</span> <span class="dt">Socket</span> m
                   , <span class="dt">MonadError</span> <span class="dt">NetError</span> m
                   , <span class="dt">MonadIO</span> m
                   , <span class="dt">ToNetworkInterpreter</span> i m
                   , <span class="dt">Binary</span> (<span class="dt">InterpreterReq</span> i)
                   , <span class="dt">Binary</span> (<span class="dt">InterpreterRes</span> i)
                   )
                <span class="ot">=&gt;</span> <span class="dt">CofreeT</span> i w (m ()) <span class="ot">-&gt;</span> m ()
pairInterpreter server <span class="fu">=</span> pairEffectM (\_ r <span class="ot">-&gt;</span> return r) (transCofreeT toNetworkInterpreter server) mkInterpreterConnector</code></pre></div>
<p>and we have the <code>FreeT (NetworkClientF (ClientReq i) (ClientRes i) m) ()</code> that the pairing function needs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkInterpreterConnector ::</span> ( <span class="dt">Functor</span> m
                          , <span class="dt">MonadReader</span> <span class="dt">Socket</span> m
                          , <span class="dt">MonadError</span> <span class="dt">NetError</span> m
                          , <span class="dt">MonadIO</span> m
                          , <span class="dt">Binary</span> req
                          , <span class="dt">Binary</span> res
                          )
                       <span class="ot">=&gt;</span> <span class="dt">FreeT</span> (<span class="dt">NetworkClientF</span> req res m) m ()
mkInterpreterConnector <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- get the socket</span>
  s <span class="ot">&lt;-</span> ask
  <span class="co">-- read and decode the request </span>
  r <span class="ot">&lt;-</span> fmap (decode <span class="fu">.</span> L.fromStrict) <span class="fu">&lt;$&gt;</span> recv s <span class="dv">1024</span>
  <span class="kw">case</span> r <span class="kw">of</span>
    <span class="co">-- stop on disconnection</span>
    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">FreeT</span> <span class="fu">$</span> throwError <span class="dt">Disconnected</span>
    <span class="dt">Just</span> x <span class="ot">-&gt;</span> <span class="dt">FreeT</span> <span class="fu">.</span> return <span class="fu">.</span> <span class="dt">Free</span> <span class="fu">.</span> <span class="dt">NetworkClientF</span> <span class="fu">$</span> (x, \t <span class="ot">-&gt;</span> <span class="kw">do</span>
      <span class="co">-- encode and send the response</span>
      _ <span class="ot">&lt;-</span> liftIO <span class="fu">.</span> send s <span class="fu">.</span> L.toStrict <span class="fu">.</span> encode <span class="fu">$</span> t
      <span class="co">-- keep on going</span>
      return mkInterpreterConnector
    )</code></pre></div>
<p>With the client we didn’t need to use recursion, since the <code>coiterT</code> in <code>mkClientConnector</code> gave us that. Here we need to make a recursive call, but we don’t make the call in the event of a disconnection.</p>
<p>We have a helper function to serve the interpreter on a particular address and port:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runInterpreter ::</span> <span class="dt">HostName</span> <span class="ot">-&gt;</span> <span class="dt">ServiceName</span> <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Socket</span> (<span class="dt">ExceptT</span> <span class="dt">NetError</span> <span class="dt">IO</span>) () <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
runInterpreter host service x <span class="fu">=</span>
  serve (<span class="dt">Host</span> host) service <span class="fu">$</span> \(sock, _) <span class="ot">-&gt;</span>
     void <span class="fu">.</span> runExceptT <span class="fu">.</span> flip runReaderT sock <span class="fu">$</span> x</code></pre></div>
<p>with which we can connect our <code>CoAdderF</code> to the network:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">networkInterpreter ::</span> <span class="dt">HostName</span> <span class="ot">-&gt;</span> <span class="dt">ServiceName</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
networkInterpreter host service <span class="fu">=</span> runInterpreter host service (pairInterpreter <span class="fu">$</span> mkCoAdderWithLogging <span class="dv">10</span> <span class="dv">0</span>)</code></pre></div>
<h1 id="conclusion">Conclusion</h1>
<p>There were a few pieces in here, but we should be able to get some good usage out of them in the future.</p>
<p>Next we will revisit the products and sums of functors (and the pairings between them). I figured out a bit of this on my own, but the <a href="https://github.com/kosmikus/SSGEP/blob/master/LectureNotes.pdf">excellent course notes by Andres Löh</a> got me the rest of the way there.</p>
<p>After that we will be looking at how to pair our coproduct-based DSLs and product-based interpreters over the network.</p>
<p>Since we have the various actions in serialized form, we can make further use of that. This could involve playing around with event sourcing - which has a lot of fun side-alleys associated with it - or it could involve setting up a write-ahead log in an attempt to make the pairing-over-the-network atomic an durable.</p>
<p>I’ve got a growing queue of <code>Cofree</code>-based topics I want to write about, so some of those things might come later.</p>
<p><a href="https://www.reddit.com/r/haskell/comments/3k1ch7/pairing_over_the_network/">Questions? Comments?</a></p>]]></description>
    <pubDate>Mon, 07 Sep 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/cofun/posts/pairing_over_the_network.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Coproducts for free and products for cofree</title>
    <link>http://dlaing.org/cofun/posts/coproducts_for_free_and_products_for_cofree.html</link>
    <description><![CDATA[<h1 id="coproducts-for-free-monads">Coproducts for free monads</h1>
<p>In the last two posts, we have <a href="/posts/free_and_cofree.html">built a DSL from a free monad and the corresponding interpreter from a cofree comonad</a> and <a href="/posts/monad_transformers_and_comonad_transformers.html">cleaned up the interpreter with comonad transformers</a>.</p>
<p>The comonad transformers helped to factor out common concerns - in this case, passing in configuration and handling state.</p>
<p>We can separate out our concerns even further than this.</p>
<p>The underlying functor for our DSL is</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AdderF</span> k <span class="fu">=</span>
    <span class="dt">Add</span> <span class="dt">Int</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> k)
  <span class="fu">|</span> <span class="dt">Clear</span> k
  <span class="fu">|</span> <span class="dt">Total</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> k)</code></pre></div>
<p>You might have noticed that the three constructors are independent of one another with respect to the <code>Functor</code> instance and the free monad. You might also have read <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.4131">Data types a la carte</a>.</p>
<p>As an aside, if you haven’t read ‘Data types a la carte’ before you should give it a go. It’s really well written, and if you’ve followed the series up to this point then you’re probably ready for it. I tried to read it very early on in my Haskell journey and ended up slowly backing away, but I’m glad I doubled back around to it eventually.</p>
<p>Anyhow.</p>
<p>We can break the independent parts out:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AddF</span> k <span class="fu">=</span> <span class="dt">Add</span> <span class="dt">Int</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> k)

<span class="kw">data</span> <span class="dt">ClearF</span> k <span class="fu">=</span> <span class="dt">Clear</span> k

<span class="kw">data</span> <span class="dt">TotalF</span> k <span class="fu">=</span> <span class="dt">Total</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> k)</code></pre></div>
<p>and we can write <code>Functor</code> instances for these:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">AddF</span> <span class="kw">where</span>
  fmap f (<span class="dt">Add</span> x k) <span class="fu">=</span> <span class="dt">Add</span> x (f <span class="fu">.</span> k)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ClearF</span> <span class="kw">where</span>
  fmap f (<span class="dt">Clear</span> k) <span class="fu">=</span> <span class="dt">Clear</span> (f k)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">TotalF</span> <span class="kw">where</span>
  fmap f (<span class="dt">Total</span> k) <span class="fu">=</span> <span class="dt">Total</span> (f <span class="fu">.</span> k)</code></pre></div>
<p>We can now recover <code>AdderF</code> by using <a href="https://hackage.haskell.org/package/transformers/docs/Data-Functor-Sum.html"><code>Sum</code></a>, which makes a <code>Functor</code> from the sum of two other <code>Functors</code>.</p>
<p>The relevant bits of <code>Sum</code> are</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Sum</span> f g a <span class="fu">=</span> <span class="dt">InL</span> (f a) <span class="fu">|</span> <span class="dt">InR</span> (g a)

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Sum</span> f g) <span class="kw">where</span>
  fmap f (<span class="dt">InL</span> x) <span class="fu">=</span> <span class="dt">InL</span> (fmap f x)
  fmap f (<span class="dt">InR</span> x) <span class="fu">=</span> <span class="dt">InR</span> (fmap f x)</code></pre></div>
<p>and we end up with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="co">-- we introduce a type operator to match &quot;Data types a la carte&quot; and Dan Piponi&#39;s post on free and cofree</span>
<span class="kw">type</span> f <span class="fu">:+:</span> g <span class="fu">=</span> <span class="dt">Sum</span> f g

<span class="kw">type</span> <span class="dt">AdderF</span> <span class="fu">=</span> <span class="dt">AddF</span> <span class="fu">:+:</span> <span class="dt">ClearF</span> <span class="fu">:+:</span> <span class="dt">TotalF</span></code></pre></div>
<p>which will behave in the same manner the old <code>AdderF</code> as far as the <code>Functor</code> instance - and hence the free monad - is concerned.</p>
<h2 id="classier-coproducts">Classier coproducts</h2>
<p>With some help from the typeclass machinery introduced in “Data types a la carte”, we can make our combinators more flexible.</p>
<p>The relevant machinery is as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> sub, <span class="dt">Functor</span> sup) <span class="ot">=&gt;</span> sub <span class="fu">:&lt;:</span> sup <span class="kw">where</span>
<span class="ot">  inj ::</span> sub a <span class="ot">-&gt;</span> sup a

<span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> f <span class="fu">:&lt;:</span> f <span class="kw">where</span>
  inj <span class="fu">=</span> id

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> f <span class="fu">:&lt;:</span> (f <span class="fu">:+:</span> g) <span class="kw">where</span>
  inj <span class="fu">=</span> <span class="dt">InL</span>

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g, <span class="dt">Functor</span> h, f <span class="fu">:&lt;:</span> g) <span class="ot">=&gt;</span> f <span class="fu">:&lt;:</span> (h <span class="fu">:+:</span> g) <span class="kw">where</span>
  inj <span class="fu">=</span> <span class="dt">InR</span> <span class="fu">.</span> inj</code></pre></div>
<p>This allows us to set up a constraint <code>f :&lt;: g</code>, which asserts that <code>f</code> is somewhere in the sum of functors <code>g</code>. Where that constraint holds we can also convert an <code>f</code> into a <code>g</code> with <code>inj</code>.</p>
<p>As an aside, Phil Wadler <a href="http://wadler.blogspot.com.au/2008/02/data-types-la-carte.html">noted</a> that the above machinery is asymmetric - which means that while</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">:&lt;:</span> d <span class="fu">:+:</span> e <span class="fu">:+:</span> f <span class="fu">:+:</span> g</code></pre></div>
<p>is fine</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">f <span class="fu">:&lt;:</span> d <span class="fu">:+:</span> (e <span class="fu">:+:</span> f) <span class="fu">:+:</span> g</code></pre></div>
<p>is not.</p>
<p>There are a few solutions posted in the comments section of that post. I’m not sure what the current best practice is on that front. I’ll be looking into it later, but if anyone has any pointers or thoughts on the topic I’d love to hear about it.</p>
<p>The above machine is fine for this post, as long as we’re reasonably careful.</p>
<p>With the new tool in the toolbox, we can now do the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> (<span class="dt">MonadFree</span> f m, <span class="dt">AddF</span> <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">Bool</span>
add x <span class="fu">=</span> liftF <span class="fu">.</span> inj <span class="fu">$</span> <span class="dt">Add</span> x id</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">clear ::</span> (<span class="dt">MonadFree</span> f m, <span class="dt">ClearF</span> <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> m ()
clear <span class="fu">=</span> liftF <span class="fu">.</span> inj <span class="fu">$</span> <span class="dt">Clear</span> ()</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">total ::</span> (<span class="dt">MonadFree</span> f m, <span class="dt">TotalF</span> <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> m <span class="dt">Int</span>
total <span class="fu">=</span> liftF <span class="fu">.</span> inj <span class="fu">$</span> <span class="dt">Total</span> id</code></pre></div>
<p>These can be put in separate modules and imported as needed by client code.</p>
<p>That’s probably not so impressive in this case. As a more impressive example, we could build up separate DSLs for authentication, database access and logging, and then mix and match to get whatever custom combination we needed, with the ability to make use of any code we’d built up on top of the individual DSLs (or combinations of those DSLs).</p>
<p>To see how this looks, we can update <code>findLimit</code> to work in a larger number of contexts:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findLimit ::</span> (<span class="dt">MonadFree</span> f m, <span class="dt">AddF</span> <span class="fu">:&lt;:</span> f, <span class="dt">ClearF</span> <span class="fu">:&lt;:</span> f, <span class="dt">TotalF</span> <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> m <span class="dt">Int</span>
findLimit <span class="fu">=</span> <span class="kw">do</span>
   <span class="co">-- capture the old count</span>
   t <span class="ot">&lt;-</span> total
   <span class="co">-- clear the count and the state</span>
   clear
   r <span class="ot">&lt;-</span> execStateT findLimit&#39; <span class="dv">0</span>
   <span class="co">-- restore the old count</span>
   clear
   _ <span class="ot">&lt;-</span> add t
   return r

<span class="ot">findLimit&#39; ::</span> (<span class="dt">MonadFree</span> f m, <span class="dt">AddF</span> <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> <span class="dt">StateT</span> <span class="dt">Int</span> m ()
findLimit&#39; <span class="fu">=</span> <span class="kw">do</span>
  r <span class="ot">&lt;-</span> lift <span class="fu">$</span> add <span class="dv">1</span>
  when r <span class="fu">$</span> <span class="kw">do</span>
    modify (<span class="fu">+</span> <span class="dv">1</span>)
    findLimit&#39;</code></pre></div>
<p>While it looks pretty similar to how it did before, we can now use <code>findLimit</code> with a free monad that has additional components in its underlying functor.</p>
<p>We could also have broken things up further, with</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">reset ::</span> (<span class="dt">MonadFree</span> f m, <span class="dt">ClearF</span> <span class="fu">:&lt;:</span> f, <span class="dt">TotalF</span> <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> m <span class="dt">Int</span>
reset <span class="fu">=</span> <span class="kw">do</span>
   <span class="co">-- capture the old count</span>
   t <span class="ot">&lt;-</span> total
   <span class="co">-- clear the count and the state</span>
   clear
   return t</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">restore ::</span> (<span class="dt">MonadFree</span> f m, <span class="dt">AddF</span> <span class="fu">:&lt;:</span> f, <span class="dt">ClearF</span> <span class="fu">:&lt;:</span> f) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m ()
restore <span class="fu">=</span> <span class="kw">do</span>
   <span class="co">-- restore the old count</span>
   clear
   _ <span class="ot">&lt;-</span> add t
   return ()</code></pre></div>
<p>Restricting our types down to just the things that we need is great - it provides more info about what the functions can and cannot do, and it means that there are less moving parts and so less ways to write the functions incorrectly.</p>
<h1 id="products-for-cofree-comonads">Products for cofree comonads</h1>
<p>That’s all well and good for the DSL, but we now need to update our interpreter to work with it.</p>
<p>Remember that we had an underlying functor for our interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoAdderF</span> k <span class="fu">=</span> <span class="dt">CoAdderF</span> {
<span class="ot">    addH   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>,k)
  ,<span class="ot"> clearH ::</span> k
  ,<span class="ot"> totalH ::</span> (<span class="dt">Int</span>,k)
  }</code></pre></div>
<p>and a pairing between our DSL and interpreter functors</p>
<p>We can factor those out into independent pieces as well.</p>
<p><code>CoAdderF</code> gets broken in a similar manner to what we did with <code>AdderF</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoAddF</span> k <span class="fu">=</span> <span class="dt">CoAdd</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, k))

<span class="kw">data</span> <span class="dt">CoClearF</span> k <span class="fu">=</span> <span class="dt">CoClear</span> k

<span class="kw">data</span> <span class="dt">CoTotalF</span> k <span class="fu">=</span> <span class="dt">CoTotal</span> (<span class="dt">Int</span>, k)</code></pre></div>
<p>and we can easily make the corresponding <code>Functor</code> instances:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">CoAddF</span> <span class="kw">where</span>
  fmap f (<span class="dt">CoAdd</span> a) <span class="fu">=</span> <span class="dt">CoAdd</span> (fmap (fmap f) a)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">CoClearF</span> <span class="kw">where</span>
  fmap f (<span class="dt">CoClear</span> k) <span class="fu">=</span> <span class="dt">CoClear</span> (f k)

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">CoTotalF</span> <span class="kw">where</span>
  fmap f (<span class="dt">CoTotal</span> t) <span class="fu">=</span> <span class="dt">CoTotal</span> (fmap f t)</code></pre></div>
<p>In the same way that we used the <code>Sum</code> to recover <code>AdderF</code>, we can use <a href="https://hackage.haskell.org/package/transformers/docs/Data-Functor-Sum.html"><code>Product</code></a> to recover <code>CoAdderF</code>.</p>
<p>The relevant bits of <code>Product</code> are</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Product</span> f g a <span class="fu">=</span> <span class="dt">Pair</span> (f a) (g a)

<span class="kw">instance</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Product</span> f g) <span class="kw">where</span>
  fmap h (<span class="dt">Pair</span> f g) <span class="fu">=</span> <span class="dt">Pair</span> (fmap h f) (fmap h g)</code></pre></div>
<p>which gives us</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="co">-- we introduce a type operator to match &quot;Data types a la carte&quot; and Dan Piponi&#39;s post on free and cofree</span>
<span class="kw">type</span> f <span class="fu">:*:</span> g <span class="fu">=</span> <span class="dt">Product</span> f g

<span class="kw">type</span> <span class="dt">CoAdderF</span> <span class="fu">=</span> <span class="dt">CoAddF</span> <span class="fu">:*:</span> <span class="dt">CoClearF</span> <span class="fu">:*:</span> <span class="dt">CoTotalF</span></code></pre></div>
<p>Again, the new version of <code>CoAdderF</code> will behave in the same way as the old version as far as we’re concerned.</p>
<p>Our old interpreter functions had types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coAdd   ::</span> (<span class="dt">ComonadEnv</span> <span class="dt">Int</span> w, <span class="dt">ComonadStore</span> <span class="dt">Int</span> w) <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, w a)
<span class="ot">coClear ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> w a
<span class="ot">coTotal ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> (<span class="dt">Int</span>, w a)</code></pre></div>
<p>but the new ones have a constructor wrapping up most of the details</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coAdd   ::</span> (<span class="dt">ComonadEnv</span> <span class="dt">Int</span> w, <span class="dt">ComonadStore</span> <span class="dt">Int</span> w) <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">CoAddF</span> (w a)
<span class="ot">coClear ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">CoClearF</span> (w a)
<span class="ot">coTotal ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">CoTotalF</span>(w a)</code></pre></div>
<p>Aside from the changes associated with those new constructors, the implementations don’t change much:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coAdd ::</span> (<span class="dt">ComonadEnv</span> <span class="dt">Int</span> w, <span class="dt">ComonadStore</span> <span class="dt">Int</span> w) <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">CoAddF</span> (w a)
coAdd w <span class="fu">=</span> <span class="dt">CoAdd</span> <span class="fu">$</span> \x <span class="ot">-&gt;</span>
  <span class="kw">let</span>
    count <span class="fu">=</span> pos w
    limit <span class="fu">=</span> ask w
    count&#39; <span class="fu">=</span> count <span class="fu">+</span> x
    test <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
    next <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count
  <span class="kw">in</span>
    (test, seek next w)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coClear ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">CoClearF</span> (w a)
coClear <span class="fu">=</span> <span class="dt">CoClear</span> <span class="fu">.</span> seek <span class="dv">0</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coTotal ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">CoTotalF</span> (w a)
coTotal w <span class="fu">=</span> <span class="dt">CoTotal</span> (pos w, w)</code></pre></div>
<p>Just like the components of our DSL, the components of the interpreter can all be placed in different modules and mixed and matched as we like.</p>
<p>We just need something to stitch these together. Since <code>coiter</code> takes a function <code>a -&gt; f a</code> and <code>coiterT</code> takes a function <code>w a -&gt; f (w a)</code>, we should be able to do our stitching in terms of <code>a -&gt; f a</code> for the various components and have it work for either <code>coiter</code> or <code>coiterT</code>.</p>
<p>What we need is something to combine two of these functions into a product:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(*:*) ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> g a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (f <span class="fu">:*:</span> g) a
(<span class="fu">*:*</span>) <span class="fu">=</span> liftA2 <span class="dt">Pair</span></code></pre></div>
<p>which we can use to update the definition of <code>mkCoAdder</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CoAdderF</span> <span class="fu">=</span> <span class="dt">CoAddF</span> <span class="fu">:*:</span> <span class="dt">CoClearF</span> <span class="fu">:*:</span> <span class="dt">CoTotalF</span>

<span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoFreeT</span> <span class="dt">CoAdderF</span> (<span class="dt">StoreT</span> <span class="dt">Int</span> (<span class="dt">EnvT</span> <span class="dt">Int</span> <span class="dt">Identity</span>)) ()
mkCoAdder limit count <span class="fu">=</span>
    coiterT next start
  <span class="kw">where</span>
    next <span class="fu">=</span> coAdd <span class="fu">*:*</span> coClear <span class="fu">*:*</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<h1 id="pairings">Pairings</h1>
<p>The last piece of the puzzle is to establish a <code>Pairing</code> between <code>AdderF</code> and <code>CoAdderF</code>. Previously, this was</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">CoAdderF</span> <span class="dt">AdderF</span> <span class="kw">where</span>
  pair f (<span class="dt">CoAdderF</span> a _ _) (<span class="dt">Add</span> x k) <span class="fu">=</span> pair f (a x) k
  pair f (<span class="dt">CoAdderF</span> _ c _) (<span class="dt">Clear</span> k) <span class="fu">=</span> f c k
  pair f (<span class="dt">CoAdderF</span> _ _ t) (<span class="dt">Total</span> k) <span class="fu">=</span> pair f t k</code></pre></div>
<p>There are pairings between <code>Sum</code> and <code>Product</code> functors if there are pairings between their components:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Pairing</span> f f&#39;, <span class="dt">Pairing</span> g g&#39;) <span class="ot">=&gt;</span> <span class="dt">Pairing</span> (f <span class="fu">:+:</span> g) (f&#39; <span class="fu">:*:</span> g&#39;) <span class="kw">where</span>
  pair p (<span class="dt">InL</span> x) (<span class="dt">Pair</span> a _) <span class="fu">=</span> pair p x a
  pair p (<span class="dt">InR</span> x) (<span class="dt">Pair</span> _ b) <span class="fu">=</span> pair p x b

<span class="kw">instance</span> (<span class="dt">Pairing</span> f f&#39;, <span class="dt">Pairing</span> g g&#39;) <span class="ot">=&gt;</span> <span class="dt">Pairing</span> (f <span class="fu">:*:</span> g) (f&#39; <span class="fu">:+:</span> g&#39;) <span class="kw">where</span>
  pair p (<span class="dt">Pair</span> a _) (<span class="dt">InL</span> x) <span class="fu">=</span> pair p a x
  pair p (<span class="dt">Pair</span> _ b) (<span class="dt">InR</span> x) <span class="fu">=</span> pair p b x</code></pre></div>
<p>This means that we only need to provide pairings between the corresponding functors from the DSL and interpreter functors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">CoAddF</span> <span class="dt">AddF</span> <span class="kw">where</span>
  pair f (<span class="dt">CoAdd</span> a) (<span class="dt">Add</span> x k) <span class="fu">=</span> pair f (a x) k

<span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">CoClearF</span> <span class="dt">ClearF</span> <span class="kw">where</span>
  pair f (<span class="dt">CoClear</span> c) (<span class="dt">Clear</span> k) <span class="fu">=</span> f c k

<span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">CoTotalF</span> <span class="dt">TotalF</span> <span class="kw">where</span>
  pair f (<span class="dt">CoTotal</span> t) (<span class="dt">Total</span> k) <span class="fu">=</span> pair f t k</code></pre></div>
<p>and we’ll be back to where we were:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">AdderF</span>   <span class="fu">=</span> <span class="dt">AddF</span> <span class="fu">:+:</span> <span class="dt">ClearF</span> <span class="fu">:+:</span> <span class="dt">TotalF</span>
<span class="co">-- There is a Functor instance for AdderF if there are</span>
<span class="co">-- Functor instances for each of AddF, ClearF and TotalF</span>

<span class="kw">type</span> <span class="dt">CoAdderF</span> <span class="fu">=</span> <span class="dt">CoAddF</span> <span class="fu">:*:</span> <span class="dt">CoClearF</span> <span class="fu">:*:</span> <span class="dt">CoTotalF</span>
<span class="co">-- There is a Functor instance for CoAdder if there are</span>
<span class="co">-- Functor instances for each of CoAddF, CoClearF and CoTotalF</span>

<span class="co">-- There is a Pairing instance for CoAdderF an AdderF if there are</span>
<span class="co">-- Pairing instances for each of AddF / CoAddF, ClearF / CoClearF and TotalF / CoTotalF</span></code></pre></div>
<p>Everything should work out as before, and we’ve gained the ability to mix and match functionality in both the DSL and the interpreter.</p>
<p>Even though we have the parts of the interpreter separated out, they still interact via the underlying comonad transformers. This provides another axis for combination and reuse.</p>
<p>For example, you can write reusable code on top of component <code>X</code>, you can write reusable code on top of component <code>Y</code>, and you can also write reusable code on top of the combination of components <code>X</code> and <code>Y</code> and a <code>ComonadStore Int w</code> context.</p>
<p>Lots of fun to be had.</p>
<h1 id="conclusion-and-open-questions">Conclusion and open questions</h1>
<p>We now have a decent separation of concerns for our DSL and interpreter, and the ability to mix and match DSLs and interpreters together.</p>
<p>It also means that we can write functions that work with the DSL or interpreter in a context where we only have access to the components that we really need. This increases the scope for reuse and decreases the scope for writing misbehaving code, and I’m a fan of both of those.</p>
<p>I’m still interested in how to do better with the “Data types a la carte” machinery. With the current machinery, we need to make sure that our <code>Sum</code>s and <code>Product</code>s have the same components in the same order. It feels like it should be possible to do significantly better than this, such that:</p>
<ul>
<li>the components are guaranteed to be unique and the order doesn’t matter (effectively a Set)
<ul>
<li>this should also deal with the current problem of asymmetry</li>
</ul></li>
<li>if the <code>Sum</code> components are a subset of the <code>Product</code> components we can automatically create a <code>Pairing</code> from the <code>Pairing</code>s between the components.</li>
</ul>
<p>I’ll probably tinker with this eventually, but if someone gets there before I do I’ll be pretty happy.</p>
<p>I’m also curious about whether we can <a href="http://stackoverflow.com/a/21395817">go even further than Sum and Product</a>, although I’m still not clear on how far that can be pushed in this context to make things more useful.</p>
<p>There’s still a few posts to come before I’ve covered everything I mentioned in the talk.</p>
<p>So far, none of the interpreters we’ve defined have done any <code>IO</code>. The <a href="/posts/pairing_and_io.html">next post</a> will look at our options for dealing with effects in our DSLs and interpreters.</p>
<p><a href="https://www.reddit.com/r/haskell/comments/3beiti/coproducts_for_free_and_products_for_cofree/">Questions? Comments?</a></p>]]></description>
    <pubDate>Sun, 28 Jun 2015 23:00:00 UT</pubDate>
    <guid>http://dlaing.org/cofun/posts/coproducts_for_free_and_products_for_cofree.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Monad transformers and comonad transformers</title>
    <link>http://dlaing.org/cofun/posts/monad_transformers_and_comonad_transformers.html</link>
    <description><![CDATA[<h1 id="the-story-so-far">The story so far</h1>
<p><a href="/posts/free_and_cofree.html">Previously</a> we put together a DSL using the free monad and a corresponding interpreter using the cofree comonad.</p>
<p>We had an ad-hoc interpreter for our DSL:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AdderT</span> m r <span class="ot">-&gt;</span> m r
interpret limit count a <span class="fu">=</span> <span class="kw">do</span>
  mr <span class="ot">&lt;-</span> runFreeT a
  <span class="kw">case</span> mr <span class="kw">of</span>
    <span class="dt">Pure</span> r <span class="ot">-&gt;</span> return r
    <span class="dt">Free</span> (<span class="dt">Add</span> x k) <span class="ot">-&gt;</span>
      <span class="kw">let</span>
        count&#39; <span class="fu">=</span> x <span class="fu">+</span> count
        test <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
        next <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count
      <span class="kw">in</span>
        interpret limit next (k test)
    <span class="dt">Free</span> (<span class="dt">Clear</span> k) <span class="ot">-&gt;</span>
      interpret limit <span class="dv">0</span> k
    <span class="dt">Free</span> (<span class="dt">Total</span> k) <span class="ot">-&gt;</span>
      interpret limit count (k count)</code></pre></div>
<p>We also had an interpreter based on the cofree comonad that corresponds to the DSL:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CoAdder</span> a <span class="fu">=</span> <span class="dt">Cofree</span> <span class="dt">CoAdderF</span> a

<span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
mkCoAdder limit count <span class="fu">=</span> coiter next start
  <span class="kw">where</span>
    next  <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> (limit, count)

<span class="ot">coAdd ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, (<span class="dt">Int</span>, <span class="dt">Int</span>))
coAdd (limit, count) x <span class="fu">=</span> (test, (limit, next))
  <span class="kw">where</span>
    count&#39; <span class="fu">=</span> count <span class="fu">+</span> x
    test   <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
    next   <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count

<span class="ot">coClear ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)
coClear (limit, _) <span class="fu">=</span> (limit, <span class="dv">0</span>)

<span class="ot">coTotal ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, (<span class="dt">Int</span>, <span class="dt">Int</span>))
coTotal (limit, count) <span class="fu">=</span> (count, (limit, count))</code></pre></div>
<p>Both of these work, but we can do better. The ad-hoc interpreter can be cleaned up by using monad transformers. It should be unsurprising - especially given the title of this post - that we can clean up the cofree comonad version of the interpreter using comonad transformers.</p>
<h1 id="a-monad-transformers-refresher">A monad transformers refresher</h1>
<p>If you’re comfortable with monad transformers you can skip this. If you’re not yet comfortable with monad transformers this probably won’t help much.</p>
<p>A few people have found these links helpful:</p>
<ul>
<li><a href="http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf">Monad Transformers Step by Step (PDF)</a></li>
<li><a href="http://www.muitovar.com/monad/moncow.xhtml">The Greenhorn’s Guide to becoming a Monad Cowboy</a></li>
</ul>
<p>I’ll at least put in a token effort, and some of the examples and analogies will be reused when I get to comonad transformers, so it’s not all a waste.</p>
<p>If you’ve ready my <a href="/posts/comonads.html">brief overview of comonads</a> you might recall my hand-wavy explanation of how monads are related to building up a value in a monadic context from a pure values.</p>
<p>We might need to look at the <code>Monad</code> typeclass at the correct angle to see that.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return    ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  bind      ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</code></pre></div>
<p>It shouldn’t be too much of stretch to see that <code>return</code> does this directly. If we think of <code>m a</code> as an intermediate step on the way to building up <code>m b</code>, <code>bind</code> can be viewed as a way to use a function from a pure value to a value in a monadic context to make that step.</p>
<p>Throughout all of this, we are working with a single <code>Monad</code>. We will often want to write code that deals with more than one monad at the same time.</p>
<p>That is where monad transformers come into play. They “stack” monads on top of each other, via the <code>lift</code> function from the <code>MonadTrans</code> typeclass.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span>
<span class="ot">  lift ::</span> m a <span class="ot">-&gt;</span> t m a</code></pre></div>
<p>Every monad transformer is also a monad, so we’re again build up a value in a monadic context. Now we can use monadic values from lower in the “stack” to do so, by “lifting” them to the context of the monad transformer.</p>
<p>This will probably make more sense after some examples.</p>
<h2 id="state-and-statet"><code>State</code> and <code>StateT</code></h2>
<p>The <code>State</code> monad abstracts functions that transform a state value of a given type. It is a <code>newtype</code> wrapper around a particular form of a state transformation function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="fu">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a, s) }</code></pre></div>
<p>The <code>newtype</code> is used so that we can provide a <code>Monad</code> instance. At least for me, it also helps me keep my types lining up nicely and prevents various late-night-coding-induced misbehaviours.</p>
<p>We use return and bind to build up more involved state transformation functions, and we can use <code>get</code> / <code>put</code> / <code>modify</code> to query and manipulate the state in these functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get ::</span> <span class="dt">State</span> s s
<span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()
<span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</code></pre></div>
<p>These functions are captured in the <code>MonadState s</code> typeclass, which has instances available in all of the places that you’d expect.</p>
<p>Once we’ve built up the state transformation function that we want, we can use <code>runState</code> / <code>evalState</code> / <code>execState</code> as our interpreters, which run the state transformation function and provide either the return value, the final state, or both. Note that <code>evalState</code> and <code>execState</code> can both be defined in terms of <code>runState</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evalState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
<span class="ot">execState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</code></pre></div>
<p>Where <code>State</code> works for pure computations, <code>StateT</code> does the same for monadic computations for a particular monad <code>m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">StateT</span> s m a <span class="fu">=</span> <span class="dt">StateT</span> {<span class="ot"> runStateT ::</span> s <span class="ot">-&gt;</span> m (a, s) }

<span class="ot">get ::</span> <span class="dt">StateT</span> s m s
<span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m ()
<span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">StateT</span> s m ()

<span class="ot">evalStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m a
<span class="ot">execStateT ::</span> <span class="dt">StateT</span> s m a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> m s</code></pre></div>
<p>We can write all of our code in terms of <code>StateT</code>, as we can use the <code>Identity</code> monad at the bottom of our stack to finish things off.</p>
<p>In fact, we can define <code>State</code> in terms of <code>StateT</code> and <code>Identity</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">State</span> s <span class="fu">=</span> <span class="dt">StateT</span> s <span class="dt">Identity</span>

<span class="ot">runState ::</span> <span class="dt">State</span> s <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)
runState sm <span class="fu">=</span> runIdentity <span class="fu">.</span> runStateT sm</code></pre></div>
<h3 id="an-example">An example</h3>
<p>We used <code>StateT</code> stacked on top of our <code>Adder</code> monad in the helper function for <code>findLimit</code> in the last post:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="co">-- in findLimit</span>
  <span class="fu">...</span>
  r <span class="ot">&lt;-</span> execStateT findLimit&#39; <span class="dv">0</span>
  <span class="fu">...</span>

<span class="ot">findLimit&#39; ::</span> <span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">Adder</span> ()
findLimit&#39; <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- add 1 to the total</span>
  r <span class="ot">&lt;-</span> lift <span class="fu">$</span> add <span class="dv">1</span>
  <span class="co">-- check for overflow</span>
  when r <span class="fu">$</span> <span class="kw">do</span>
    <span class="co">-- if no overflow, add to our state counter ...</span>
    modify (<span class="fu">+</span> <span class="dv">1</span>)
    <span class="co">-- and continue</span>
    findLimit&#39;</code></pre></div>
<p>This is a good example of using <code>lift</code> to build up the values in a monad stack and using the various domain specific functions to help interpret them.</p>
<p>Inside of <code>findLimit</code>, we can make use of <code>modify</code> because <code>StateT</code> is on top of the stack.</p>
<p>If we remember the type of <code>add</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Adder</span> <span class="dt">Bool</span></code></pre></div>
<p>we can see that it’s not going to work in the <code>StateT Int Adder</code> stack that <code>findLimit'</code> is expecting.</p>
<p>However, <code>lift . add</code> has type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lift <span class="fu">.</span><span class="ot"> add ::</span> <span class="dt">MonadTrans</span> t <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> t <span class="dt">Adder</span> <span class="dt">Bool</span></code></pre></div>
<p>or in this case</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">lift <span class="fu">.</span><span class="ot"> add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">Adder</span> <span class="dt">Bool</span></code></pre></div>
<p>and so everything works out.</p>
<p>While <code>findLimit'</code> has type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">Adder</span> ()</code></pre></div>
<p>we can see that <code>execStateT findLimit' (0 :: Int)</code> has type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Adder</span> <span class="dt">Int</span></code></pre></div>
<p>and so <code>execStateT</code> has allowed us to temporarily make use of an additional effect.</p>
<h2 id="reader-and-readert"><code>Reader</code> and <code>ReaderT</code></h2>
<p>The <code>Reader</code> monad abstracts functions that operate with a value of a given type as a context or environment. In this case it is a <code>newtype</code> wrapper around a simple function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="fu">=</span> <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }</code></pre></div>
<p>and we use <code>runReader</code> to interpret a <code>Reader</code> monad value once we’re done building it up.</p>
<p>The <code>MonadReader r</code> typeclass captures the <code>Reader</code> specific functions, although for this post we’ll only be making us of <code>ask</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ask ::</span> <span class="dt">Reader</span> r r </code></pre></div>
<p>which returns the environment value.</p>
<p>Just like with <code>State</code>, we can make use of <code>Reader</code> in a monad transformer stack with <code>ReaderT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="fu">=</span> <span class="dt">Reader</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }

<span class="ot">ask ::</span> <span class="dt">ReaderT</span> r m r</code></pre></div>
<p>and we can also define <code>Reader</code> in terms of <code>ReaderT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Reader</span> r <span class="fu">=</span> <span class="dt">ReaderT</span> r <span class="dt">Identity</span>

<span class="ot">runReader ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> a
runReader <span class="fu">=</span> runIdentity <span class="fu">.</span> runReaderT</code></pre></div>
<h2 id="cleaning-up-the-ad-hoc-interpreter">Cleaning up the ad-hoc interpreter</h2>
<p>The ad-hoc interpreter is manually doing the work of a <code>State</code> monad for the count and a <code>Reader</code> monad for the limit.</p>
<p>Let us clean that up, using <code>Reader</code> over <code>State</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Base</span> m <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Int</span> (<span class="dt">StateT</span> <span class="dt">Int</span> m)

<span class="ot">runBase ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Base</span> m r <span class="ot">-&gt;</span> m r
runBase limit count <span class="fu">=</span>
  flip evalStateT count <span class="fu">.</span>
  flip runReaderT limit</code></pre></div>
<p>We have a helper function, <code>interpret'</code>, which builds up a value of <code>Base m r</code>. We have written the code for <code>AdderT</code> and the <code>add</code>/<code>clear</code>/<code>total</code> helpers so that they’re generic in the underlying monads. This is where that genericity pays off - we have deferred mentioning the underlying monad right up until the point where we are interpreting our DSL, and so we can choose whatever monad we want.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret&#39; ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> (<span class="dt">Base</span> m) r <span class="ot">-&gt;</span> <span class="dt">Base</span> m r
interpret&#39; a <span class="fu">=</span> <span class="kw">do</span>
  mr <span class="ot">&lt;-</span> runFreeT a
  <span class="kw">case</span> mr <span class="kw">of</span>
    <span class="dt">Pure</span> r <span class="ot">-&gt;</span> return r
    <span class="dt">Free</span> (<span class="dt">Add</span> x k) <span class="ot">-&gt;</span> <span class="kw">do</span>
      limit <span class="ot">&lt;-</span> ask
      count <span class="ot">&lt;-</span> lift get
      <span class="kw">let</span> count&#39; <span class="fu">=</span> x <span class="fu">+</span> count
      <span class="kw">let</span> test <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
      <span class="kw">let</span> next <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count
      lift <span class="fu">.</span> put <span class="fu">$</span> next
      interpret&#39; (k test)
    <span class="dt">Free</span> (<span class="dt">Clear</span> k) <span class="ot">-&gt;</span> <span class="kw">do</span>
      lift <span class="fu">.</span> put <span class="fu">$</span> <span class="dv">0</span>
      interpret&#39; k
    <span class="dt">Free</span> (<span class="dt">Total</span> k) <span class="ot">-&gt;</span> <span class="kw">do</span>
      count <span class="ot">&lt;-</span> lift get
      interpret&#39; (k count)</code></pre></div>
<p>Since <code>ReaderT</code> is at the top of the stack in <code>Base</code>, we can use <code>ask</code> directly.</p>
<p>We need to use <code>lift</code> whenever we deal with the state. This transforms computations in the <code>StateT Int m</code> monad into computations in the <code>ReaderT Int (StateT Int m)</code> monad, which is what we are working in.</p>
<p>We can combine both of these to get our cleaned up interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AdderT</span> (<span class="dt">Base</span> m) r <span class="ot">-&gt;</span> m r
interpret limit count <span class="fu">=</span>
  runBase limit count <span class="fu">.</span>
  interpret&#39;</code></pre></div>
<p>At this point we’re no longer explicitly threading a read-only environment value and an updatable state value through our computation and instead we access that functionality through a well-defined interface. Things are nicer, at least in the realm of the ad-hoc version of the interpreter.</p>
<h2 id="transformers-style-and-mtl-style"><code>transformers</code> style and <code>mtl</code> style</h2>
<p>There are different schools of thought on whether to use <code>transformers</code> style monad transformers - in which you have concrete types and you use explicit lifts - or <code>mtl</code> style monad transformers - in which you use typeclass constraints and don’t have to lift anything.</p>
<p>I lean slightly towards working with <code>mtl</code> style transformers, since I like the ease with which I can use it for prototyping and putting together pieces that I might reuse - even if the reuse is just between now and the next refactoring. Anyhow.</p>
<p>With <code>transformers</code> your code is explicit, and you can have multiple transformers of the same type in your stack.</p>
<p>With <code>mtl</code> you can’t have multiple transformers of the same type, but you can easily write code that is decoupled from the concrete stack you end up using.</p>
<p>This only involves a change to <code>interpret'</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Base</span> m <span class="fu">=</span> <span class="dt">ReaderT</span> <span class="dt">Int</span> (<span class="dt">StateT</span> <span class="dt">Int</span> m)

<span class="ot">runBase ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Base</span> m r <span class="ot">-&gt;</span> m r
runBase limit count <span class="fu">=</span>
  flip evalStateT count <span class="fu">.</span>
  flip runReaderT limit

<span class="ot">interpret&#39; ::</span> (<span class="dt">MonadReader</span> <span class="dt">Int</span> m, <span class="dt">MonadState</span> <span class="dt">Int</span> m) <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m r <span class="ot">-&gt;</span> m r
interpret&#39; a <span class="fu">=</span> <span class="kw">do</span>
  mr <span class="ot">&lt;-</span> runFreeT a
  <span class="kw">case</span> mr <span class="kw">of</span>
    <span class="dt">Pure</span> r <span class="ot">-&gt;</span> return r
    <span class="dt">Free</span> (<span class="dt">Add</span> x k) <span class="ot">-&gt;</span> <span class="kw">do</span>
      limit <span class="ot">&lt;-</span> ask
      count <span class="ot">&lt;-</span> get
      <span class="kw">let</span> count&#39; <span class="fu">=</span> x <span class="fu">+</span> count
      <span class="kw">let</span> test <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
      <span class="kw">let</span> next <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count
      put next
      interpret&#39; (k test)
    <span class="dt">Free</span> (<span class="dt">Clear</span> k) <span class="ot">-&gt;</span> <span class="kw">do</span>
      put <span class="dv">0</span>
      interpret&#39; k
    <span class="dt">Free</span> (<span class="dt">Total</span> k) <span class="ot">-&gt;</span> <span class="kw">do</span>
      count <span class="ot">&lt;-</span> get
      interpret&#39; (k count)

<span class="ot">interpret ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AdderT</span> (<span class="dt">Base</span> m) r <span class="ot">-&gt;</span> m r
interpret limit count <span class="fu">=</span>
  runBase limit count <span class="fu">.</span>
  interpret&#39;</code></pre></div>
<p>We are using typeclass constraints to assert that the required functionality is in the monad transformer stack. We then use the functionality - <code>ask</code>, <code>get</code>, and <code>put</code> - directly, as it is all available from the typeclasses we mentioned in our typeclass constraints.</p>
<p>This means we can change the order of the transformers in the stack without having to change <code>interpret'</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret1 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AdderT</span> (<span class="dt">ReaderT</span> <span class="dt">Int</span> (<span class="dt">StateT</span> <span class="dt">Int</span> m)) r <span class="ot">-&gt;</span> m r
interpret1 limit count <span class="fu">=</span>
  flip runStateT count <span class="fu">.</span>
  flip runReaderT limit <span class="fu">.</span>
  interpret&#39;

<span class="ot">interpret2 ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AdderT</span> (<span class="dt">StateT</span> <span class="dt">Int</span> (<span class="dt">ReaderT</span> <span class="dt">Int</span> m)) r <span class="ot">-&gt;</span> m r
interpret2 limit count <span class="fu">=</span>
  flip runReaderT limit <span class="fu">.</span>
  flip runStateT count <span class="fu">.</span>
  interpret&#39;</code></pre></div>
<p>It also means we can factor out bits of the functionality, and limit the constraints to just what is required for what we’re working on:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">clearCount ::</span> <span class="dt">MonadState</span> <span class="dt">Int</span> m <span class="ot">-&gt;</span> m ()
clearCount <span class="fu">=</span> put <span class="dv">0</span></code></pre></div>
<p>Limiting the scope can mean that we can reuse the functionality in more places, and that our code can’t make sneaky use of the other transformers in the stack.</p>
<p>It is worth noting that we can get these benefits from <code>transformers</code> style code if we want to, just like we can have multiple components to our <code>Reader</code> and <code>State</code> monads in <code>mtl</code> style. There is much more to say about the two styles, and about the tools and techniques that make working with monad transformers more pleasant - including the <code>mmorph</code> library and several different parts of <code>lens</code>. Going into further details on these is probably a post for another day.</p>
<h1 id="comonad-transformers">Comonad transformers</h1>
<p>In contrast to monads, comonads are about converting values in a comonadic context to pure values. I tend to think of this is “tearing down” a value in a comonadic context where monads are “building up” a value in a monadic context, however that’s perhaps not the best metaphor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Comonad</span> w <span class="kw">where</span>
<span class="ot">  extract   ::</span> w a <span class="ot">-&gt;</span> a
<span class="ot">  extend    ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b</code></pre></div>
<p>Recall that <code>extract</code> is the dual to <code>return</code> and <code>extend</code> is the dual to <code>bind</code>. Given that, we probably won’t find it too hard to view <code>extract</code> as something that converts from values in a comonad context to pure values directly, while <code>extend</code> helps us to do something similar in stages.</p>
<p>That pattern continues with <code>lower</code> from <code>ComonadTrans</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ComonadTrans</span> t <span class="kw">where</span>
<span class="ot">  lower ::</span> t w a <span class="ot">-&gt;</span> w a</code></pre></div>
<p>Every comonad transformer is also a comonad, and we can see that <code>lower</code> is helping us step down the stack to get closer to a pure value.</p>
<p>Let’s look at a few of these things so we can get a bit more concrete.</p>
<h2 id="store-and-storet"><code>Store</code> and <code>StoreT</code></h2>
<p>The <code>Store</code> comonad is related to the <code>State</code> monad, but does things a bit differently.</p>
<p>We store a function and an initial value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Store</span> s a <span class="fu">=</span> <span class="dt">Store</span> (s <span class="ot">-&gt;</span> a) s</code></pre></div>
<p>As an aside, if we squint at (and uncurry) <code>State</code> and <code>Store</code> we might see them as combinations of <code>(-&gt; s)</code> and <code>(, s)</code> but in different orders. There are volumes more to say about that, involving the relationship between adjunctions, monads, and comonads. If you’re interested to know more, you should ask in the reddit comments - there are folks in that community that are incredibly well versed in explaining those links and the various interesting avenues that branch off from there.</p>
<p>We can use <code>fmap</code> to modify the function via composition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Store</span> s) <span class="kw">where</span>
  fmap f (<span class="dt">Store</span> g s) <span class="fu">=</span> <span class="dt">Store</span> (f <span class="fu">.</span> g) s</code></pre></div>
<p>The <code>extract</code> function applies the stored function to the stored value, and <code>duplicate</code> turns the <code>a</code> into a <code>Store s a</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Comonad</span> (<span class="dt">Store</span> s) <span class="kw">where</span>
  extract (<span class="dt">Store</span> f s) <span class="fu">=</span> f s
  duplicate (<span class="dt">Store</span> f s) <span class="fu">=</span> <span class="dt">Store</span> (<span class="dt">Store</span> f) s</code></pre></div>
<p>We have a number of helper functions - also accessible from the <code>ComonadStore s</code> typeclass - including:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pos  ::</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> s
<span class="ot">seek ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> <span class="dt">Store</span> s a
<span class="ot">peek ::</span> s <span class="ot">-&gt;</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> a</code></pre></div>
<p>where</p>
<ul>
<li><code>pos</code> gets the stored value</li>
<li><code>seek</code> sets the stored value, and</li>
<li><code>peek</code> applies the stored function to a new value</li>
</ul>
<p>We’ll be making use of <code>pos</code> and <code>seek</code> to maintain state in our interpreter.</p>
<p>In the <code>State</code> monad, <code>get</code> and <code>put</code> were able to return their values in the <code>State</code> monad, since we were building up a value in a monadic context. In the <code>Store</code> comonad, we’re tearing things down and so <code>pos</code> and <code>seek</code> look and behave like regular getter and setter functions - because that’s exactly what they are.</p>
<p>There is a <code>runStore</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runStore ::</span> <span class="dt">Store</span> s a <span class="ot">-&gt;</span> ((s <span class="ot">-&gt;</span> a), s)</code></pre></div>
<p>but it’s not as exciting as <code>runState</code>.</p>
<p>In the <code>State</code> monad, we were busily building up a state transformation function, and <code>runState</code> was the interpreter that tore it down into a pure value.</p>
<p>In the <code>Store</code> comonad, we are doing the tearing down with the comonad, but we need something to tear down in the first place. For that reason, where we were interested in the accessor functions inside the <code>newtype</code> wrappers for the monads, we are are more interested in the constructors for the <code>comonads</code>- since the constructors give our context a starting point.</p>
<p>This is also handy because we are making use of these comonad transformers in an interpreter, and that interpreter is meant to run forever. We could use <code>runStore</code> after that, for a sense of completeness, but I’ll omit it here.</p>
<p>As we might expect, there is a <code>StoreT</code> comonad transformer which corresponds with <code>Store</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">StoreT</span> s w a <span class="fu">=</span> <span class="dt">StoreT</span> (w (s <span class="ot">-&gt;</span> a)) a

<span class="ot">pos  ::</span> <span class="dt">StoreT</span> s w a <span class="ot">-&gt;</span> s
<span class="ot">seek ::</span> s <span class="ot">-&gt;</span> <span class="dt">StoreT</span> s w a <span class="ot">-&gt;</span> <span class="dt">StoreT</span> s w a
<span class="ot">peek ::</span> <span class="dt">Comonad</span> w <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">StoreT</span> s w a <span class="ot">-&gt;</span> a</code></pre></div>
<p>and we can use the <code>Identity</code> comonad to define the <code>Store</code> in terms of <code>StoreT</code>.</p>
<h2 id="env-and-envt"><code>Env</code> and <code>EnvT</code></h2>
<p>The last piece we’ll need is the <code>Env</code> comonad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Env</span> e a <span class="fu">=</span> <span class="dt">Env</span> e a</code></pre></div>
<p>which is similar to the <code>Reader</code> monad in its functionality.</p>
<p>Where <code>Reader</code> was a function from <code>e</code> to <code>a</code>, <code>Env</code> is the pair of the two values.</p>
<p>We have a helper function, also available in <code>ComonadEnv e</code>:</p>
<pre><code>ask :: Env e a -&gt; e</code></pre>
<p>that returns the environment value, and the expected transformer version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">EnvT</span> e w a <span class="fu">=</span> <span class="dt">EnvT</span> e (w a)

<span class="ot">ask ::</span> <span class="dt">EnvT</span> e w a <span class="ot">-&gt;</span> e</code></pre></div>
<h2 id="cleaning-up-our-interpreter">Cleaning up our interpreter</h2>
<p>With all of that in hand, let us clean up the cofree-based interpreter.</p>
<p>We’re adding in a transformer stack, so we’ll switch from <code>Cofree</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</code></pre></div>
<p>to <code>CofreeT</code></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CofreeF</span> f a b <span class="fu">=</span> a <span class="fu">:&lt;</span> f b
<span class="kw">data</span> <span class="dt">CofreeT</span> f w a <span class="fu">=</span> <span class="dt">CoFreeT</span> {<span class="ot"> runCofreeT ::</span> w (<span class="dt">CofreeF</span> f a (<span class="dt">CofreeT</span> f w a)) }</code></pre></div>
<p>We’re making use of <code>count</code> as a kind of state, and <code>limit</code> as a kind of environment:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Base</span> a <span class="fu">=</span> <span class="dt">StoreT</span> <span class="dt">Int</span> (<span class="dt">EnvT</span> <span class="dt">Int</span> <span class="dt">Identity</span>) a</code></pre></div>
<p>In the case of our interpreter, we have:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CoAdderT</span> w a <span class="fu">=</span> <span class="dt">CofreeT</span> <span class="dt">CoAdderF</span> w a</code></pre></div>
<p>and then we combine the two to get:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">CoAdder</span> a <span class="fu">=</span> <span class="dt">CoAdderT</span> <span class="dt">Base</span> a</code></pre></div>
<p>Now we just need to switch to the comonad transformer version of <code>coiter</code> - called <code>coiterT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coiterT ::</span> (<span class="dt">Functor</span> f, <span class="dt">Comonad</span> w) <span class="ot">=&gt;</span> (w a <span class="ot">-&gt;</span> f (w a)) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w a</code></pre></div>
<p>and update the value of <code>start</code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> ()
mkCoAdder limit count <span class="fu">=</span> coiterT next start
  <span class="kw">where</span>
    next  <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>Now <code>coAdd</code>, <code>coClear</code> and <code>coTotal</code> will change from having an argument of <code>(Int, Int)</code> to having an argument of <code>Base ()</code>. We’ll be a little more general and use <code>Base a</code> to keep the code as general as we can.</p>
<p>We have <code>StoreT</code> at the top of our comonad transformer stack, and <code>coClear</code> and <code>coTotal</code> only make use of the <code>StoreT</code> part of the stack. This means we can use the <code>seek</code> and <code>pos</code> functions directly:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coClear ::</span> <span class="dt">Base</span> a <span class="ot">-&gt;</span> <span class="dt">Base</span> a
coClear <span class="fu">=</span> seek <span class="dv">0</span>

<span class="ot">coTotal ::</span> <span class="dt">Base</span> a <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Base</span> a)
coTotal w <span class="fu">=</span> (pos w, w)</code></pre></div>
<p>As <code>coAdd</code> makes use of <code>EnvT</code>, we need to use <code>lower</code> to get access to the <code>EnvT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coAdd ::</span> <span class="dt">Base</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Base</span> a)
coAdd w x <span class="fu">=</span> (test, seek next w)
  <span class="kw">where</span>
    count  <span class="fu">=</span> pos  w
    limit  <span class="fu">=</span> ask <span class="fu">.</span> lower <span class="fu">$</span> w
    count&#39; <span class="fu">=</span> count <span class="fu">+</span> x
    test   <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
    next   <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count</code></pre></div>
<p>Party on, Wayne.</p>
<h2 id="the-hard-way">The hard way</h2>
<p>Things get a little trickier if we change the order of the transformer stack.</p>
<p>It is straight-forward to update the definition of <code>Base</code> and change the way we construct <code>start</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Base</span> a       <span class="fu">=</span> <span class="dt">EnvT</span> <span class="dt">Int</span> (<span class="dt">StoreT</span> <span class="dt">Int</span> <span class="dt">Identity</span>) a
<span class="kw">type</span> <span class="dt">CoAdderT</span> w a <span class="fu">=</span> <span class="dt">CofreeT</span> <span class="dt">CoAdderF</span> w a
<span class="kw">type</span> <span class="dt">CoAdder</span> a    <span class="fu">=</span> <span class="dt">CoAdderT</span> <span class="dt">Base</span> a

<span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> ()
mkCoAdder limit count <span class="fu">=</span>
    coiterT next start
  <span class="kw">where</span>
    next  <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>We need some fancy footwork to update the value in the <code>StoreT</code>, since <code>seek s</code> is defined as <code>peek s . duplicate</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coClear ::</span> <span class="dt">Base</span> a <span class="ot">-&gt;</span> <span class="dt">Base</span> a
coClear <span class="fu">=</span> peek <span class="dv">0</span> <span class="fu">.</span> lower <span class="fu">.</span> duplicate</code></pre></div>
<p>That might not look all that fancy, but it was one the trickiest things I had to work out to put this post together.</p>
<p>Getting access to <code>pos</code> requires that we <code>lower</code> into the <code>StoreT</code> first:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coTotal ::</span> <span class="dt">Base</span> a <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Base</span> a)
coTotal w <span class="fu">=</span> ((pos <span class="fu">.</span> lower <span class="fu">$</span> w), w)</code></pre></div>
<p>and we can use <code>ask</code> directly since <code>EnvT</code> is on the top of our stack:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coAdd ::</span> <span class="dt">Base</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Base</span> a)
coAdd w x <span class="fu">=</span> (test, peek next <span class="fu">.</span> lower <span class="fu">.</span> duplicate <span class="fu">$</span> w)
  <span class="kw">where</span>
    count  <span class="fu">=</span> pos <span class="fu">.</span> lower <span class="fu">$</span> w
    limit  <span class="fu">=</span> ask w
    count&#39; <span class="fu">=</span> count <span class="fu">+</span> x
    test   <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
    next   <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count</code></pre></div>
<p>Party on, Garth.</p>
<h1 id="from-transformers-style-to-mtl-style">From <code>transformers</code> style to <code>mtl</code> style</h1>
<p>What we have so far demonstrates the use <code>transformers</code> style comonad transformers. It’s worth showing off the differences between that and <code>mtl</code> style comonad transformers.</p>
<p>We’ll revert to <code>StoreT</code> over <code>EnvT</code> for this.</p>
<p>With <code>StoreT</code> at the top of the stack, the cases for <code>coClear</code> and <code>coTotal</code> don’t change except for the type signatures:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coClear ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> w a
coClear <span class="fu">=</span> seek <span class="dv">0</span>

<span class="ot">coTotal ::</span> <span class="dt">ComonadStore</span> <span class="dt">Int</span> w <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> (<span class="dt">Int</span>, w a)
coTotal w <span class="fu">=</span> (pos w, w)</code></pre></div>
<p>For <code>coAdd</code> we make a similar change to the type signature. We also drop the explicit <code>lower</code>, since the <code>ComonadEnv</code> constraint makes <code>ask</code> available to us no matter where it is in the stack:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coAdd ::</span> (<span class="dt">ComonadEnv</span> <span class="dt">Int</span> w, <span class="dt">ComonadStore</span> <span class="dt">Int</span> w) <span class="ot">=&gt;</span> w a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, w a)
coAdd w x <span class="fu">=</span> (test, seek next w)
  <span class="kw">where</span>
    count  <span class="fu">=</span> pos w
    limit  <span class="fu">=</span> ask w
    count&#39; <span class="fu">=</span> count <span class="fu">+</span> x
    test   <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
    next   <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count</code></pre></div>
<p>The code for <code>mkCoadder</code> doesn’t change at all. More importantly, the <code>coClear</code>, <code>coTotal</code> and <code>coAdd</code> methods don’t change even if we change the order of the transformer stack.</p>
<p>Both</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Base</span> a       <span class="fu">=</span> <span class="dt">StoreT</span> <span class="dt">Int</span> (<span class="dt">EnvT</span> <span class="dt">Int</span> <span class="dt">Identity</span>) a
<span class="kw">type</span> <span class="dt">CoAdderT</span> w a <span class="fu">=</span> <span class="dt">CofreeT</span> <span class="dt">CoAdderF</span> w a
<span class="kw">type</span> <span class="dt">CoAdder</span> a    <span class="fu">=</span> <span class="dt">CoAdderT</span> <span class="dt">Base</span> a

<span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> ()
mkCoAdder limit count <span class="fu">=</span>
    coiterT next start
  <span class="kw">where</span>
    next  <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Base</span> a       <span class="fu">=</span> <span class="dt">EnvT</span> <span class="dt">Int</span> (<span class="dt">StoreT</span> <span class="dt">Int</span> <span class="dt">Identity</span>) a
<span class="kw">type</span> <span class="dt">CoAdderT</span> w a <span class="fu">=</span> <span class="dt">CofreeT</span> <span class="dt">CoAdderF</span> w a
<span class="kw">type</span> <span class="dt">CoAdder</span> a    <span class="fu">=</span> <span class="dt">CoAdderT</span> <span class="dt">Base</span> a

<span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> ()
mkCoAdder limit count <span class="fu">=</span>
    coiterT next start
  <span class="kw">where</span>
    next  <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>will work without adjustments.</p>
<h1 id="pairing-in-the-presence-of-transformers">Pairing in the presence of transformers</h1>
<p>So far we’ve been using the <code>Pairing</code> between <code>Cofree</code> and <code>Free</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> f g <span class="ot">=&gt;</span> <span class="dt">Pairing</span> (<span class="dt">Cofree</span> f) (<span class="dt">Free</span> g) <span class="kw">where</span>
  pair p (a <span class="fu">:&lt;</span> _ ) (<span class="dt">Pure</span> x)  <span class="fu">=</span> p a x
  pair p (_ <span class="fu">:&lt;</span> fs) (<span class="dt">Free</span> gs) <span class="fu">=</span> pair (pair p) fs gs</code></pre></div>
<p>but now we’re going to need something which can handle the transformer stacks.</p>
<p>We make use of the pure value at the root of our cofree tree with <code>extract</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extract ::</span> <span class="dt">CofreeT</span> f w a <span class="ot">-&gt;</span> a</code></pre></div>
<p>and thanks to the <code>ComonadCofree</code> typeclass we can also access the rest of the tree with <code>unwrap</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unwrap ::</span> <span class="dt">Comonad</span> w <span class="ot">=&gt;</span> <span class="dt">CofreeT</span> f w a <span class="ot">-&gt;</span> f (w a)</code></pre></div>
<p>These are used in <code>pairEffect</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffect ::</span> (<span class="dt">Pairing</span> f g, <span class="dt">Comonad</span> w, <span class="dt">Monad</span> m)
           <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b <span class="ot">-&gt;</span> m r
pairEffect p s c <span class="fu">=</span> <span class="kw">do</span>
  mb <span class="ot">&lt;-</span> runFreeT c
  <span class="kw">case</span> mb <span class="kw">of</span>
    <span class="dt">Pure</span> x <span class="ot">-&gt;</span> return <span class="fu">$</span> p (extract s) x
    <span class="dt">Free</span> gs <span class="ot">-&gt;</span> pair (pairEffect p) (unwrap s) gs</code></pre></div>
<p>which interleaves handling effects and pairing DSL commands with interpreter handlers.</p>
<p>This is handy for the cases where we will continually be producing DSL commands, and so will never get to the <code>Pure</code> case in the pairing. We need that if we try to write a console based <code>Adder</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">consoleAdder&#39; ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m ()
consoleAdder&#39; <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> liftIO getLine
    <span class="kw">case</span> words l <span class="kw">of</span>
      [<span class="st">&quot;add&quot;</span>, x] <span class="ot">-&gt;</span> add (read x) <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
        output <span class="fu">$</span> <span class="st">&quot;add result: &quot;</span> <span class="fu">++</span> show b
      [<span class="st">&quot;clear&quot;</span>] <span class="ot">-&gt;</span> clear
      [<span class="st">&quot;total&quot;</span>] <span class="ot">-&gt;</span> total <span class="fu">&gt;&gt;=</span> \t <span class="ot">-&gt;</span>
        output <span class="fu">$</span> <span class="st">&quot;total result: &quot;</span> <span class="fu">++</span> show t
      _ <span class="ot">-&gt;</span> output prompt
  <span class="kw">where</span>
   output <span class="fu">=</span> liftIO <span class="fu">.</span> putStrLn
   prompt <span class="fu">=</span> unlines [
            <span class="st">&quot;Commands:&quot;</span>
          , <span class="st">&quot;  add [int]&quot;</span>
          , <span class="st">&quot;  clear&quot;</span>
          , <span class="st">&quot;  total&quot;</span>
          ]

<span class="ot">consoleAdder ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m ()
consoleAdder <span class="fu">=</span> forever consoleAdder&#39;</code></pre></div>
<p>We can use <code>pairEffect</code> to couple this with our comonad transformer version of <code>mkCoAdder</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testConsole ::</span> <span class="dt">IO</span> ()
testConsole <span class="fu">=</span> pairEffect (\_ r <span class="ot">-&gt;</span> r) (mkCoAdder <span class="dv">10</span> <span class="dv">0</span>) consoleAdder</code></pre></div>
<p>although we could just as easily have used a pure version of <code>mkCoAdder</code> stacked on top of the <code>Identity</code> comonad and <code>pairEffect</code> would have continued to work.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’ve now factored out the state and environment from the interpreter, but there are still aspects of both the DSL and the interpreter which are more strongly coupled than they need to be.</p>
<p>We’ll start to deal with this in the <a href="/posts/coproducts_for_free_and_products_for_cofree.html">next post</a>, where we’ll use coproducts to break out the orthogonal parts of the DSL and products to make a similar change to the interpreter. After that we’ll have a deeper look at making use of various effects in conjunction with free and cofree.</p>
<p><a href="http://www.reddit.com/r/haskell/comments/39vaqj/monad_transformers_and_comonad_transformers/">Questions? Comments?</a></p>]]></description>
    <pubDate>Mon, 15 Jun 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/cofun/posts/monad_transformers_and_comonad_transformers.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Pairing and IO</title>
    <link>http://dlaing.org/cofun/posts/pairing_and_io.html</link>
    <description><![CDATA[<h1 id="recap">Recap</h1>
<p>The <a href="/posts/free_and_cofree.html">first post</a> in this series covered using free monads for DSLs, cofree comonads for interpreters, and how to pair them up. This only covered pure DSLs and interpreters.</p>
<p>The <a href="/posts/monad_transformers_and_comonad_transformers.html">second post</a> in this series tidied that code up by bringing monad transformers into play for the DSL and comonad transformers into play for the interpreter. In an aside at the end of that post, I mentioned how we could update the we we do pairing to take these transformer stacks into account, and demonstrated that by adding some console <code>IO</code> into the DSL.</p>
<p>The <a href="/posts/coproducts_for_free_and_products_for_cofree.html">third post</a> in this series covered the use of coproducts and products to separate our concerns a little further.</p>
<p>Now I’ll be covering how to handle <code>IO</code> in the interpreter, and will also be using our adventures with <code>IO</code> to demonstrate how we can push the coproducts and products further.</p>
<h1 id="effects-in-the-dsl">Effects in the DSL</h1>
<p>At the start of this series, we introduced the <code>Pairing</code> typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Pairing</span> f g <span class="kw">where</span>
<span class="ot">  pair ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> r</code></pre></div>
<p>and a <code>Pairing</code> instance between <code>Cofree f</code> and <code>Free g</code>, provided that we had an instance for <code>Pairing f g</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> f g <span class="ot">=&gt;</span> <span class="dt">Pairing</span> (<span class="dt">Cofree</span> f) (<span class="dt">Free</span> g) <span class="kw">where</span>
  pair p (a <span class="fu">:&lt;</span> _ ) (<span class="dt">Pure</span> x)  <span class="fu">=</span> p a x
  pair p (_ <span class="fu">:&lt;</span> fs) (<span class="dt">Free</span> gs) <span class="fu">=</span> pair (pair p) fs gs</code></pre></div>
<p>That was fine until we wanted to add monad and comonad transformers into the mix.</p>
<p>At that point we introduced <code>pairEffect</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffect ::</span> (<span class="dt">Pairing</span> f g, <span class="dt">Comonad</span> w, <span class="dt">Monad</span> m)
           <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w a <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b <span class="ot">-&gt;</span> m r
pairEffect p s c <span class="fu">=</span> <span class="kw">do</span>
  mb <span class="ot">&lt;-</span> runFreeT c
  <span class="kw">case</span> mb <span class="kw">of</span>
    <span class="dt">Pure</span> x <span class="ot">-&gt;</span> return <span class="fu">$</span> p (extract s) x
    <span class="dt">Free</span> gs <span class="ot">-&gt;</span> pair (pairEffect p) (unwrap s) gs</code></pre></div>
<p>With <code>pair</code>, the interaction between the free monad and the cofree comonad happens when we run into the <code>Pure</code> constructor of the <code>Free</code> type.</p>
<p>We may not want to wait for that to happen when we have effects in the mix - <code>IO</code> in particular - and so <code>pairEffect</code> has been written to make sure that the effects of <code>m</code> are interleaved with the interpretation of the DSL.</p>
<p>For a demonstration of this, we’ll use <code>FreeT</code> over <code>IO</code> to interact with an interpreter via the console.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">consoleAdder&#39; ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> m ()
consoleAdder&#39; <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> liftIO getLine
    <span class="kw">case</span> words l <span class="kw">of</span>
      [<span class="st">&quot;add&quot;</span>, x] <span class="ot">-&gt;</span> add (read x) <span class="fu">&gt;&gt;=</span> \b <span class="ot">-&gt;</span>
        output <span class="fu">$</span> <span class="st">&quot;add result: &quot;</span> <span class="fu">++</span> show b
      [<span class="st">&quot;clear&quot;</span>] <span class="ot">-&gt;</span> clear
      [<span class="st">&quot;total&quot;</span>] <span class="ot">-&gt;</span> total <span class="fu">&gt;&gt;=</span> \t <span class="ot">-&gt;</span>
        output <span class="fu">$</span> <span class="st">&quot;total result: &quot;</span> <span class="fu">++</span> show t
      _ <span class="ot">-&gt;</span> output prompt
  <span class="kw">where</span>
    output <span class="fu">=</span> liftIO <span class="fu">.</span> putStrLn
    prompt <span class="fu">=</span> unlines [
             <span class="st">&quot;Commands:&quot;</span>
           , <span class="st">&quot;  add [int]&quot;</span>
           , <span class="st">&quot;  clear&quot;</span>
           , <span class="st">&quot;  total&quot;</span>
           ]

<span class="ot">consoleAdder ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> m ()
consoleAdder <span class="fu">=</span> forever consoleAdder&#39;</code></pre></div>
<p>This is nothing fancier than parsing some input to choose which action we want, printing a help message if the input didn’t parse, and looping continuously via <code>forever</code>.</p>
<p>We can run it using <code>pairEffect</code> with our existing pure interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect (\_ r <span class="ot">-&gt;</span> r) (mkCoAdder <span class="dv">10</span> <span class="dv">0</span>) consoleAdder</code></pre></div>
<p>and we’ll be able to interact with it productively, despite the fact that <code>consoleAdder</code> doesn’t terminate.</p>
<h1 id="effects-in-the-interpreter">Effects in the interpreter</h1>
<p>That’s good, but it is a bit unsatisfactory since we can’t do any IO in the interpreter itself.</p>
<p>Let us change <code>pairEffect</code> so that we can do IO in the interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffect ::</span> (<span class="dt">Pairing</span> f g, <span class="dt">Comonad</span> w, <span class="dt">Monad</span> m)
           <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w (m a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b <span class="ot">-&gt;</span> m r
pairEffect p s c <span class="fu">=</span> <span class="kw">do</span>
  a  <span class="ot">&lt;-</span> extract s
  mb <span class="ot">&lt;-</span> runFreeT c
  <span class="kw">case</span> mb <span class="kw">of</span>
    <span class="dt">Pure</span> x <span class="ot">-&gt;</span> return <span class="fu">$</span> p a x
    <span class="dt">Free</span> gs <span class="ot">-&gt;</span> pair (pairEffect p) (unwrap s) gs</code></pre></div>
<p>This does the effect in <code>CofreeT</code> before the effect in <code>FreeT</code>. We can alter this function or write a new one if we want the effects to happen in the opposite order, although it seems unlikely that we’ll need that.</p>
<h3 id="altering-the-effects">Altering the effects</h3>
<p>We may not always want or need the same monad stack on both the DSL and interpreter sides of things.</p>
<p>That’s easy enough to fix.</p>
<p>We can change our stack around on the <code>FreeT</code> side using <code>hoistFreeT</code> from <code>Control.Monad.Trans.Free</code> in the <a href="https://hackage.haskell.org/package/free">free</a> package:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hoistFreeT ::</span> (<span class="dt">Monad</span> m, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> (forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> f m b <span class="ot">-&gt;</span> <span class="dt">FreeT</span> f n b</code></pre></div>
<p>and we can alter the stack in <code>CofreeT</code> by using <code>fmap</code>.</p>
<p>After that, we can use things like <code>lift</code> for simple changes, or <a href="http://hackage.haskell.org/package/mmorph">mmorph</a> for more complex changes.</p>
<p>If we can come up with morphisms</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">morphL ::</span> <span class="dt">Monad</span> l <span class="ot">=&gt;</span> forall a<span class="fu">.</span> l a <span class="ot">-&gt;</span> n a</code></pre></div>
<p>and</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">morphM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> forall a<span class="fu">.</span> m a <span class="ot">-&gt;</span> n a</code></pre></div>
<p>we can do</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pairEffect&#39; ::</span> (<span class="dt">Pairing</span> f g, <span class="dt">Comonad</span> w, <span class="dt">Monad</span> l, <span class="dt">Monad</span> m, <span class="dt">Monad</span> n)
           <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">CofreeT</span> f w (l a) <span class="ot">-&gt;</span> <span class="dt">FreeT</span> g m b <span class="ot">-&gt;</span> n r
pairEffect&#39; p s c <span class="fu">=</span> pairEffect p (fmap morphL s) (hoistFreeT morphM c)</code></pre></div>
<p>For now, I’ll assume we’re using the same monad stack for our effects for the DSL and the interpeter.</p>
<h3 id="updating-the-console-example">Updating the console example</h3>
<p>To show off our new <code>pairEffect</code>, We’ll split the console example so that the client takes care of the parsing and the interpreter takes care of printing the results.</p>
<p>This begins with a new <code>consoleAdder</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">consoleAdder&#39; ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m ()
consoleAdder&#39; <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> liftIO getLine
    <span class="kw">case</span> words l <span class="kw">of</span>
      [<span class="st">&quot;add&quot;</span>, x] <span class="ot">-&gt;</span> void <span class="fu">$</span> add (read x)
      [<span class="st">&quot;clear&quot;</span>] <span class="ot">-&gt;</span> clear
      [<span class="st">&quot;total&quot;</span>] <span class="ot">-&gt;</span> void total
      _ <span class="ot">-&gt;</span> output prompt
  <span class="kw">where</span>
    output <span class="fu">=</span> liftIO <span class="fu">.</span> putStrLn
    prompt <span class="fu">=</span> unlines [
             <span class="st">&quot;Commands:&quot;</span>
           , <span class="st">&quot;  add [int]&quot;</span>
           , <span class="st">&quot;  clear&quot;</span>
           ,<span class="st">&quot;  total&quot;</span>
           ]

<span class="ot">consoleAdder ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m ()
consoleAdder <span class="fu">=</span> forever consoleAdder&#39;</code></pre></div>
<p>which no longer prints the results.</p>
<p>We then update our old interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdder ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> ()
mkCoAdder limit count <span class="fu">=</span>
    coiterT next start
  <span class="kw">where</span>
    next <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>so that it will print the results of the actions it carries out.</p>
<p>For each action, we’ll use the return value to create an <code>IO</code> action which prints the return value, and we’ll push it down to the next level of the cofree comonad.</p>
<p>We’ll do this using this helper function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">addResultLogging ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">CoAdderF</span> (f a) <span class="ot">-&gt;</span> <span class="dt">CoAdderF</span> (f (<span class="dt">IO</span> ()))
addResultLogging (<span class="dt">CoAdderF</span> a c t) <span class="fu">=</span> <span class="dt">CoAdderF</span> a&#39; c&#39; t&#39;
  <span class="kw">where</span>
    a&#39; x <span class="fu">=</span>
      <span class="kw">let</span>
        (b, k) <span class="fu">=</span> a x
      <span class="kw">in</span>
        (b, putStrLn (<span class="st">&quot;add result: &quot;</span> <span class="fu">++</span> show b) <span class="fu">&lt;$</span> k)
    c&#39; <span class="fu">=</span> return () <span class="fu">&lt;$</span> c
    t&#39; <span class="fu">=</span>
      <span class="kw">let</span>
        (i, k) <span class="fu">=</span> t
      <span class="kw">in</span>
        (i, putStrLn (<span class="st">&quot;total result: &quot;</span> <span class="fu">++</span> show i) <span class="fu">&lt;$</span> k)</code></pre></div>
<p>We can use <code>addResultLogging</code> to make a new interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdderWithLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> (<span class="dt">IO</span> ())
mkCoAdderWithLogging limit count <span class="fu">=</span>
    coiterT (addResultLogging <span class="fu">&lt;$&gt;</span> next) (return () <span class="fu">&lt;$</span> start)
  <span class="kw">where</span>
    next <span class="fu">=</span> <span class="dt">CoAdderF</span> <span class="fu">&lt;$&gt;</span> coAdd <span class="fu">&lt;*&gt;</span> coClear <span class="fu">&lt;*&gt;</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">$</span> const ()</code></pre></div>
<p>which we can run with:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect (\_ r <span class="ot">-&gt;</span> r) (mkCoAdderWithLogging <span class="dv">10</span> <span class="dv">0</span>) consoleAdder</code></pre></div>
<p>We now have <code>IO</code> in our DSL and in our interpreter.</p>
<p>There are other variants on this these, although they’re mostly used when the <code>Pure</code> constructor of the <code>Free</code> monad is driving things. Two variants I’ve seen around the internet that seem like they’d be pretty handy are</p>
<ul>
<li>working with <code>Cofree f (a -&gt; b)</code> and <code>Free a</code></li>
<li>working with <code>Cofree f (a -&gt; m b)</code> and <code>FreeT m a</code></li>
</ul>
<h1 id="effects-with-coproducts-and-products">Effects with coproducts and products</h1>
<p>We need to work a little harder to use this with coproducts and products, but it was fun to play around with, and I think it’s interesting.</p>
<p>For the DSL side of things, we need two things for each of the components:</p>
<ul>
<li>the text to print in the help message</li>
<li>the parser for the input</li>
</ul>
<p>We’ll capture both of those in the <code>ConsoleClient</code> class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ConsoleClient</span> f <span class="kw">where</span>
<span class="ot">  prompt ::</span> <span class="dt">Proxy</span> (f ()) <span class="ot">-&gt;</span> [<span class="dt">String</span>]
<span class="ot">  parser ::</span> (<span class="dt">Monad</span> m, <span class="dt">CharParsing</span> m) <span class="ot">=&gt;</span> m (f ())</code></pre></div>
<p>For the help message data, we use a <code>Proxy</code> so that we can associate the data with our instances. For the parser, we return a parser from the <a href="https://hackage.haskell.org/package/parsers">parsers</a> package.</p>
<p>We can add instances of <code>ConsoleClient</code> for each of our components:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleClient</span> <span class="dt">AddF</span> <span class="kw">where</span>
  prompt _ <span class="fu">=</span> [<span class="st">&quot;add (int)&quot;</span>]
  parser <span class="fu">=</span>
    string <span class="st">&quot;add&quot;</span> <span class="fu">&gt;&gt;</span>
    space <span class="fu">&gt;&gt;</span>
    many digit <span class="fu">&gt;&gt;=</span> \xs <span class="ot">-&gt;</span>
    return <span class="fu">$</span> <span class="dt">Add</span> (read xs) (const ())</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleClient</span> <span class="dt">TotalF</span> <span class="kw">where</span>
  prompt _ <span class="fu">=</span> [<span class="st">&quot;total&quot;</span>]
  parser <span class="fu">=</span> <span class="kw">do</span>
    void <span class="fu">$</span> string <span class="st">&quot;total&quot;</span>
    return <span class="fu">$</span> <span class="dt">Total</span> (const ())</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleClient</span> <span class="dt">ClearF</span> <span class="kw">where</span>
  prompt _ <span class="fu">=</span> [<span class="st">&quot;clear&quot;</span>]
  parser <span class="fu">=</span> <span class="kw">do</span>
    void <span class="fu">$</span> string <span class="st">&quot;clear&quot;</span>
    return <span class="fu">$</span> <span class="dt">Clear</span> ()</code></pre></div>
<p>and we can combine these components automatically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">ConsoleClient</span> a, <span class="dt">ConsoleClient</span> b) <span class="ot">=&gt;</span> <span class="dt">ConsoleClient</span> (a <span class="fu">:+:</span> b) <span class="kw">where</span>
  prompt _ <span class="fu">=</span>
    prompt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (a ())) <span class="fu">++</span>
    prompt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (b ()))
  parser <span class="fu">=</span> try (fmap <span class="dt">InL</span> parser) <span class="fu">&lt;|&gt;</span> fmap <span class="dt">InR</span> parser</code></pre></div>
<p>These can be stitched together to form a much more general version of <code>runConsole</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runConsole&#39; ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadIO</span> m, <span class="dt">ConsoleClient</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> f m ()
runConsole&#39; <span class="fu">=</span>
    liftIO getLine <span class="fu">&gt;&gt;=</span>
        either (\_ <span class="ot">-&gt;</span> output help) liftF <span class="fu">.</span>
        parse parser <span class="st">&quot;console parser&quot;</span>
  <span class="kw">where</span>
    output <span class="fu">=</span> liftIO <span class="fu">.</span> putStrLn
    help <span class="fu">=</span> unlines <span class="fu">.</span>
      (<span class="st">&quot;Commands:&quot;</span> <span class="fu">:</span>) <span class="fu">.</span>
      map (<span class="st">&quot;  &quot;</span> <span class="fu">++</span>) <span class="fu">$</span>
      prompt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (f ()))

<span class="ot">runConsole ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadIO</span> m, <span class="dt">ConsoleClient</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">FreeT</span> f m ()
runConsole <span class="fu">=</span> forever runConsole&#39;</code></pre></div>
<p>The main step here is to read a line, parse it, and then either lift the parsed value to our <code>FreeT</code> if the parse succeeds or print the help message if the parse fails.</p>
<p>This will work with any <code>Sum</code> of <code>ConsoleClient</code>s, which is nice.</p>
<p>Unsurprisingly, we can also abstract the changes to the interpreter on a per component basis.</p>
<p>To begin with, we’ll generalize <code>addResultLogging</code> to a class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ConsoleInterpreter</span> f <span class="kw">where</span>
<span class="ot">  addResultLogging ::</span> <span class="dt">Functor</span> g <span class="ot">=&gt;</span> f (g a) <span class="ot">-&gt;</span> f (g (<span class="dt">IO</span> ()))</code></pre></div>
<p>We create instances for each of our components:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleInterpreter</span> <span class="dt">CoAddF</span> <span class="kw">where</span>
  addResultLogging (<span class="dt">CoAdd</span> f) <span class="fu">=</span> <span class="dt">CoAdd</span> (fmap (\(b, k) <span class="ot">-&gt;</span> (b, putStrLn (<span class="st">&quot;add result: &quot;</span> <span class="fu">++</span> show b) <span class="fu">&lt;$</span> k)) f)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleInterpreter</span> <span class="dt">CoTotalF</span> <span class="kw">where</span>
  addResultLogging (<span class="dt">CoTotal</span> (i, k)) <span class="fu">=</span> <span class="dt">CoTotal</span> (i, putStrLn (<span class="st">&quot;total result: &quot;</span> <span class="fu">++</span> show i) <span class="fu">&lt;$</span> k)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">ConsoleInterpreter</span> <span class="dt">CoClearF</span> <span class="kw">where</span>
  addResultLogging (<span class="dt">CoClear</span> k) <span class="fu">=</span> <span class="dt">CoClear</span> (return () <span class="fu">&lt;$</span> k)</code></pre></div>
<p>and we can stitch them all together generically:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">ConsoleInterpreter</span> a, <span class="dt">ConsoleInterpreter</span> b) <span class="ot">=&gt;</span> <span class="dt">ConsoleInterpreter</span> (a <span class="fu">:*:</span> b) <span class="kw">where</span>
  addResultLogging (a <span class="fu">:*:</span> b) <span class="fu">=</span> addResultLogging a <span class="fu">:*:</span> addResultLogging b</code></pre></div>
<p>We can now update <code>mkCoAdder</code> exactly as we did before:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mkCoAdderWithLogging ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> (<span class="dt">IO</span> ())
mkCoAdderWithLogging limit count <span class="fu">=</span>
    coiterT (addResultLogging <span class="fu">&lt;$&gt;</span> next) (return () <span class="fu">&lt;$</span> start)
  <span class="kw">where</span>
    next <span class="fu">=</span> coAdd <span class="fu">*:*</span> coClear <span class="fu">*:*</span> coTotal
    start <span class="fu">=</span> flip <span class="dt">StoreT</span> count <span class="fu">.</span> <span class="dt">EnvT</span> limit <span class="fu">.</span> <span class="dt">Identity</span> <span class="fu">.</span> const <span class="fu">$</span> ()</code></pre></div>
<p>At some point it’d be nice to put together something like <code>reiterT</code>, with the goal of being able to rework a <code>CoAdder ()</code> into a <code>CoAdder (IO ())</code> more generically and without having to write a new version of <code>mkCoAdder</code>. I’ll update this post if or when I get around to it (or if someone else has a good suggestion for it).</p>
<p>We can run this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect&#39; (\_ r <span class="ot">-&gt;</span> r) (mkCoAdderWithLogging <span class="dv">10</span> <span class="dv">0</span>) (<span class="ot">runConsole ::</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> <span class="dt">IO</span> ())</code></pre></div>
<p>but we need an explicit type signature for <code>runConsole</code>.</p>
<p>We can switch from Dan Piponi’s version of <code>Pairing</code> to Ed Kmett’s version at this point:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Pairing</span> f g <span class="fu">|</span> f <span class="ot">-&gt;</span> g, g <span class="ot">-&gt;</span> f <span class="kw">where</span>
<span class="ot">  pair ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> r</code></pre></div>
<p>Adding the <code>FunctionalDependencies</code> help drive the inference, although it looks like we may need <code>UndecidableInstances</code> to get the pairing between <code>:+:</code> and <code>:*:</code> to work.</p>
<p>This lets us write <code>run</code> like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">run ::</span> <span class="dt">IO</span> ()
run <span class="fu">=</span> pairEffect&#39; (\_ r <span class="ot">-&gt;</span> r) (mkCoAdderWithLogging <span class="dv">10</span> <span class="dv">0</span>) runConsole</code></pre></div>
<p>in which case the type of <code>runConsole</code> will be inferred to match the type of <code>mkCoAdderWithLogging</code>, which is pretty neat.</p>
<h1 id="conclusion">Conclusion</h1>
<p>We’re starting to build up a set of handy ideas.</p>
<p>It’s worth mentioning that this has mostly been by me wondering if I can do something, and then following the types and adapting to them to problems as I come across them. The point is that none of this is set in stone, and there are a lot of ways these things can be sliced and diced in fun ways. So if you’re branching out and hit a roadblock with some of the pieces that I’ve mentioned in these posts, try to rework it (or replace it) - if there’s any deep theory in play here it is almost entirely unintentional.</p>
<p>Next time, I’ll be <a href="/posts/pairing_over_the_network.html">pairing our DSL and interpreter over a network</a>.</p>
<p><a href="https://www.reddit.com/r/haskell/comments/3d0fgf/free_cofree_and_io/">Questions? Comments?</a></p>]]></description>
    <pubDate>Fri, 12 Jun 2015 23:00:00 UT</pubDate>
    <guid>http://dlaing.org/cofun/posts/pairing_and_io.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>A whirlwind tour of comonads</title>
    <link>http://dlaing.org/cofun/posts/comonads.html</link>
    <description><![CDATA[<h1 id="a-whirlwind-tour-of-comonads">A whirlwind tour of comonads</h1>
<p>I recommend Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html">explanation</a> if you haven’t read it before.</p>
<p>I’m posting this because</p>
<ul>
<li>it’s part of what I covered in my talk, and I’m converting the rest of it blog form, so why not?</li>
<li>some people won’t read the above link, and some intuition about comonads is going to help when I start talking about comonad transformers</li>
</ul>
<p>I’m mostly interested in conveying some intuition about comonads here, but I’ll start with the typeclass and the laws. Hopefully that will provide a kind of road map that might help when translating the things you’ve learned about monads into a comonadic setting.</p>
<h2 id="the-typeclasses-and-the-laws">The typeclasses and the laws</h2>
<p>Recall the typeclass for <code>Monad</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span>
<span class="ot">  return    ::</span> a <span class="ot">-&gt;</span> m a
<span class="ot">  bind      ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
<span class="ot">  join      ::</span> m (m a) <span class="ot">-&gt;</span> m a</code></pre></div>
<p>You might be more used to the operator <code>&gt;&gt;=</code> instead of <code>bind</code>. They’re the same function with their arguments flipped. You may also have come across <code>bind</code> in operator form as <code>=&lt;&lt;</code>. I’m using <code>bind</code> here to highlight the <code>Monad</code> / <code>Comonad</code> symmetry that will make an appearance in a moment.</p>
<p>With monads, we’re building up values in a monadic context from pure values. I hope it is easy to see that <code>return</code> converts a pure value to a value in the monadic context directly.</p>
<p>We can look at <code>bind</code> as some thing that helps us build up a value in a monadic context in stages. We’re aiming for a <code>m b</code>, we’ve already managed to get hold of an <code>m a</code>. We just need to provide a function to bridge between them, and that function will also build up a value in a monadic context from a pure value.</p>
<p>To get to <code>Comonad</code>, we flip everything.</p>
<p>With the usual drollness, this includes the type parameter <code>m</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Comonad</span> w <span class="kw">where</span>
<span class="ot">  extract   ::</span> w a <span class="ot">-&gt;</span> a
<span class="ot">  extend    ::</span> (w a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b
<span class="ot">  duplicate ::</span> w a <span class="ot">-&gt;</span> w (w a)</code></pre></div>
<p>With comonads, we’re tearing down values in a comonadic context to get pure values.</p>
<p>Again, <code>extract</code> does this directly while <code>extend</code> helps us “step down” in stages.</p>
<p>The laws also go through a similar transformation.</p>
<p>The monad laws are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  bind return     <span class="fu">=</span> id
  bind f <span class="fu">.</span> return <span class="fu">=</span> f
  bind f <span class="fu">.</span> bind g <span class="fu">=</span> bind (bind f <span class="fu">.</span> g)</code></pre></div>
<p>and the comonad laws are:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"> extend extract      <span class="fu">=</span> id
 extract <span class="fu">.</span> extend f  <span class="fu">=</span> f
 extend f <span class="fu">.</span> extend g <span class="fu">=</span> extend (f <span class="fu">.</span> extend g)</code></pre></div>
<p>There different sets of comonad laws depending on which definitions you provide in the typeclass, and they’re all inter-related. It is worth checking out the <a href="https://hackage.haskell.org/package/comonad/docs/Control-Comonad.html">haddocks</a> to get a sense of those relationships.</p>
<p>Monads and comonads are both also functors, which we can see from these two functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">fmapFromMonad ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b
fmapFromMonad f <span class="fu">=</span> bind (return <span class="fu">.</span> f)

<span class="ot">fmapFromComonad ::</span> <span class="dt">Comonad</span> w <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> w a <span class="ot">-&gt;</span> w b
fmapFromComonad f <span class="fu">=</span> extend (f <span class="fu">.</span> extract)</code></pre></div>
<p>As an exercise for the motivated reader, can you use the <code>Monad</code> / <code>Comonad</code> laws to show that the above functions obey the <code>Functor</code> laws?</p>
<h2 id="list-zippers">List zippers</h2>
<p>I think one of the better ways of conveying the intuition of comonads - at least when working with a “container” analogy - is with the List zipper.</p>
<p>The List zipper represents a non-empty list, with a focus on a particular element:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ListZipper</span> a <span class="fu">=</span>
  <span class="dt">ListZipper</span>
    [a] <span class="co">-- the elements before the focus, in reverse order</span>
     a  <span class="co">-- the focus</span>
    [a] <span class="co">-- the elements after the focus</span></code></pre></div>
<p>This lets us move the focus left and right efficiently:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">leftMay ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ListZipper</span> a)
leftMay (<span class="dt">ListZipper</span> [] f rs)       <span class="fu">=</span> <span class="dt">Nothing</span>
leftMay (<span class="dt">ListZipper</span> (l <span class="fu">:</span> ls) f rs) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">ListZipper</span> ls l (f <span class="fu">:</span> rs)

<span class="co">-- stay put if we&#39;re at the far left end</span>
<span class="ot">left ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> a
left z <span class="fu">=</span> maybe z leftMay z

<span class="ot">rightMay ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ListZipper</span> a)
rightMay (<span class="dt">ListZipper</span> ls f [])       <span class="fu">=</span> <span class="dt">Nothing</span>
rightMay (<span class="dt">ListZipper</span> ls f (r <span class="fu">:</span> rs)) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">ListZipper</span> (f <span class="fu">:</span> ls) r rs

<span class="co">-- stay put if we&#39;re at the far right end</span>
<span class="ot">right ::</span> <span class="dt">ListZipper</span> a <span class="ot">-&gt;</span> <span class="dt">ListZipper</span> a
right z <span class="fu">=</span> maybe z rightMay z</code></pre></div>
<p>It is pretty easy to come up with a <code>Functor</code> instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ListZipper</span> <span class="kw">where</span>
  fmap g (<span class="dt">ListZipper</span> ls f rs) <span class="fu">=</span> <span class="dt">ListZipper</span> (fmap g ls) (g f) (fmap g rs)</code></pre></div>
<p>We can define a <code>Comonad</code> instance, but you don’t need to worry about the details for most of these posts:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Maybe</span> (catMaybes, isJust)

<span class="kw">instance</span> <span class="dt">Comonad</span> <span class="dt">ListZipper</span> <span class="kw">where</span>
  extract (<span class="dt">ListZipper</span> _ f _) <span class="fu">=</span> f
  duplicate z <span class="fu">=</span> <span class="dt">ListZipper</span> lefts z rights
    <span class="kw">where</span>
      gather f <span class="fu">=</span> tail <span class="fu">.</span> catMaybes <span class="fu">.</span> takeWhile isJust <span class="fu">.</span> iterate (<span class="fu">&gt;&gt;=</span> f) <span class="fu">.</span> <span class="dt">Just</span>
      lefts <span class="fu">=</span> gather leftMay z
      rights <span class="fu">=</span> gather rightMay z</code></pre></div>
<p>With a suitable <code>Show</code> instance, we can see that <code>extract</code> does what we’d expect:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">let</span> z <span class="fu">=</span> <span class="dt">ListZipper</span> [<span class="dv">2</span>, <span class="dv">1</span>] <span class="dv">3</span> [<span class="dv">4</span>]

<span class="fu">&gt;</span> z
<span class="fu">|</span> <span class="dv">1</span> <span class="fu">|</span> <span class="dv">2</span> <span class="fu">&gt;</span> <span class="dv">3</span> <span class="fu">&lt;</span> <span class="dv">4</span> <span class="fu">|</span>

<span class="fu">&gt;</span> extract z
<span class="dv">3</span></code></pre></div>
<p>I’ll take some license with the <code>Show</code> instance to demonstrate <code>duplicate</code>:</p>
<pre><code>&gt; duplicate z
||  &gt;1&lt;2|3|4| || |1&gt;2&lt;3|4| &gt;&gt; |1|2&gt;3&lt;4| &lt;&lt; |1|2|3&gt;4&lt; ||</code></pre>
<p>For <code>extend</code>, it’s time to break out some graphs.</p>
<p>Just say we have some list zipper, <code>z</code>:</p>
<div class="figure">
<img src="/images/comonad-graph1.png" />

</div>
<p>The focus is unspecified, but it’s not going to change throughout these examples.</p>
<p>Given a function that finds the greatest value to the left of the focus:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Safe</span> (maximumDef)

<span class="ot">latch ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Zipper</span> a <span class="ot">-&gt;</span> a
latch (<span class="dt">Zipper</span> l f _) <span class="fu">=</span>
  maximumDef f l</code></pre></div>
<p>we can create a list zipper of the highest values as seen when moving from left to right through the zipper:</p>
<div class="figure">
<img src="/images/comonad-graph2.png" />

</div>
<p>Given a function to determine if the focus is greater than both of its immediate neighbours:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Safe</span> (headDef)

<span class="ot">peak ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Zipper</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>
peak (<span class="dt">Zipper</span> l f r) <span class="fu">=</span>
  headDef f l <span class="fu">&lt;</span> f <span class="fu">&amp;&amp;</span> f <span class="fu">&gt;</span> headDef f r</code></pre></div>
<p>we can find all of the points which are greater than their neighbours:</p>
<div class="figure">
<img src="/images/comonad-graph3.png" />

</div>
<p>Given a function to find the average value with a certain distance of the focus:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">wma ::</span>  <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Zipper</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
wma n (<span class="dt">Zipper</span> l f r) <span class="fu">=</span>
  average <span class="fu">$</span> take n l <span class="fu">++</span> f <span class="fu">:</span> take n r</code></pre></div>
<p>we can find the windowed moving average of the entire list zipper:</p>
<div class="figure">
<img src="/images/comonad-graph4.png" />

</div>
<p>We can also compose these functions:</p>
<div class="figure">
<img src="/images/comonad-graph5.png" />

</div>
<h2 id="conclusion">Conclusion</h2>
<p>Aside from the fact that there’s a comonad behind every zipper (which you can read more about <a href="http://www.ioc.ee/~tarmo/tsem05/uustalu0812-slides.pdf">here (PDF)</a> and <a href="http://stackoverflow.com/questions/25554062/zipper-comonads-generically?lq=1">here</a>), there’s quite a bit more to say about the humble list zipper on it’s own, but that will be the topic of a future series of posts…</p>]]></description>
    <pubDate>Thu, 04 Jun 2015 02:00:00 UT</pubDate>
    <guid>http://dlaing.org/cofun/posts/comonads.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>
<item>
    <title>Free for DSLs, cofree for interpreters</title>
    <link>http://dlaing.org/cofun/posts/free_and_cofree.html</link>
    <description><![CDATA[<h1 id="free-for-dsls-cofree-for-interpreters">Free for DSLs, cofree for interpreters</h1>
<p>This is the first post in a series of posts, which will cover the material from a talk I gave at YOW! Lambda Jam, titled “Cofun with Cofree Comonads”.</p>
<p>The slides, these posts, and the associated code are in the <a href="https://github.com/dalaing/cofun">github repository</a>, although the code is evolving at a steady pace and the code that supports future draft posts is likely to change a lot between now and when I get the related blog posts together.</p>
<h2 id="an-introduction-to-free-monads-for-dsls">An introduction to free monads for DSLs</h2>
<p>I’m not going to be getting into the underlying theory of free monads to any extent in these posts.</p>
<p>Instead I’ll be focusing on the use of free monads in order to build something like a DSL (domain-specific language).</p>
<p>Gabriel Gonzalez has written some great posts on free monads <a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html">here</a> and <a href="http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html">here</a>. If you haven’t come across free monads before, I recommend reading those posts before continuing, because I’m most likely going to butcher the explanation in my rush to get to cofree.</p>
<h3 id="free">Free</h3>
<p>The <code>Free</code> data type has two constructors:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Free</span> f a <span class="fu">=</span>
    <span class="dt">Pure</span> a
  <span class="fu">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</code></pre></div>
<p>If you squint, this can be viewed as a kind of tree.</p>
<p>The <code>Pure</code> constructor can be viewed as the leaves of a tree. The <code>Free</code> constructor can be viewed as the branches. If <code>f</code> is a <code>Functor</code> and we use the functors-as-containers analogy, then we have a container of <code>Free f a</code>s.</p>
<p>Additionally, if <code>f</code> is a <code>Functor</code> then we can define a <code>Monad</code> instance for <code>Free f</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span>
  return x <span class="fu">=</span> <span class="dt">Pure</span> x
  (<span class="dt">Pure</span> r) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f r
  (<span class="dt">Free</span> x) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Free</span> (fmap (<span class="fu">&gt;&gt;=</span> f) x)</code></pre></div>
<p>In the above instance</p>
<ul>
<li><code>return</code> turns a pure value into a leaf of the tree</li>
<li><code>&gt;&gt;=</code> takes a function for turning pure values into trees, and substitutes the leaves with the trees which result from running that function on the values in the leaves</li>
</ul>
<h3 id="our-toy-dsl">Our toy DSL</h3>
<p>It turns out this is pretty handy for defining and working with DSLs, so lets put a toy DSL together in order to see what this actually gives us.</p>
<p>The DSL will be used to track the running total as we add to, clear, and query the total.</p>
<p>First we need to define the underlying functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">AdderF</span> k <span class="fu">=</span>
    <span class="dt">Add</span> <span class="dt">Int</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> k)
  <span class="fu">|</span> <span class="dt">Clear</span> k
  <span class="fu">|</span> <span class="dt">Total</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> k)</code></pre></div>
<p>The type parameter <code>k</code> can be thought of as “what to do next”.</p>
<p>The DSL will have three commands</p>
<ul>
<li>add an <code>Int</code> to the total, after which we get hold of a <code>Bool</code> which indicates if we can continue
<ul>
<li>if the <code>Bool</code> is <code>true</code>, the <code>Int</code> has been added to the total</li>
<li>if the <code>Bool</code> is <code>false</code>, the <code>Int</code> would have overflowed the counter the service is using to track the total, so the total is left unchanged</li>
<li>we can use that <code>Bool</code> to determine what we will do next</li>
</ul></li>
<li>clear the total, and then move on to the next DSL action.</li>
<li>ask for the total
<ul>
<li>we can choose our next action based on the <code>Int</code> that we get back.</li>
</ul></li>
</ul>
<p>This has a functor instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">AdderF</span> <span class="kw">where</span>
  fmap f (<span class="dt">Add</span> x k) <span class="fu">=</span> <span class="dt">Add</span> x (f <span class="fu">.</span> k)
  fmap f (<span class="dt">Clear</span> k) <span class="fu">=</span> <span class="dt">Clear</span> (f k)
  fmap f (<span class="dt">Total</span> k) <span class="fu">=</span> <span class="dt">Total</span> (f <span class="fu">.</span> k)</code></pre></div>
<p>but we could have turned on the <code>DeriveFunctor</code> language extension and gotten this for free.</p>
<p>Now we have what we need to create a monad for manipulating our DSL:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Adder</span> a <span class="fu">=</span> <span class="dt">Free</span> <span class="dt">AdderF</span> a</code></pre></div>
<p>At this point we have lost our <code>k</code> parameter from before.</p>
<p>If we unfold the definitions a little, we end up with the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Adder</span> a <span class="fu">=</span>
    <span class="dt">Pure</span> a
  <span class="fu">|</span> <span class="dt">Free</span> (<span class="dt">Add</span> <span class="dt">Int</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Adder</span> a))
  <span class="fu">|</span> <span class="dt">Free</span> (<span class="dt">Clear</span> (<span class="dt">Adder</span> a))
  <span class="fu">|</span> <span class="dt">Free</span> (<span class="dt">Total</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Adder</span> a)</code></pre></div>
<p>If we were thinking of <code>k</code> as “what to do next”, it is now either</p>
<ul>
<li>return a value</li>
<li>carry out another action in the <code>Adder</code> monad</li>
</ul>
<p>We can also add some extra effects into the mix by using <code>FreeT</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">AdderT</span> m a <span class="fu">=</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> m a</code></pre></div>
<h3 id="combinators-for-the-dsl">Combinators for the DSL</h3>
<p>At the moment this is a bit inconvenient to work with, so we use <code>liftF</code> from the <code>free</code> package to build the combinators for working in our language from the data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Adder</span> <span class="dt">Bool</span>
add x <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Add</span> x id

<span class="ot">clear ::</span> <span class="dt">Adder</span> ()
clear <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Clear</span> ()

<span class="ot">total ::</span> <span class="dt">Adder</span> <span class="dt">Int</span>
total <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Total</span> id</code></pre></div>
<p>We can generalize this in order to work with other effects:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">AdderT</span> m a <span class="fu">=</span> <span class="dt">FreeT</span> <span class="dt">AdderF</span> m a

<span class="ot">add ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AdderT</span> m <span class="dt">Bool</span>
add x <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Add</span> x id

<span class="ot">clear ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m ()
clear <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Clear</span> ()

<span class="ot">total ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">AdderT</span> m <span class="dt">Int</span>
total <span class="fu">=</span> liftF <span class="fu">$</span> <span class="dt">Total</span> id</code></pre></div>
<p>If we instantiate <code>m</code> as <code>Identity</code> then the two are equivalent.</p>
<p>And that’s it. We know have our own monad for manipulating the DSL, which means we can use <code>do</code>-notation, we can sequence and traverse these commands, and generally go to town with all of the existing machinery we have in the Haskell ecosystem for building things with monads.</p>
<p>We also haven’t made any reference to how this DSL will be interpreted. That gives us a lot of freedom, which also allows us to build different interpreters for testing and for production without changing our DSL or anything built on top of it.</p>
<h3 id="building-some-extensions">Building some extensions</h3>
<p>We know that the counter tracking the total <em>can</em> overflow, but we don’t have the ability to ask what it’s limit is.</p>
<p>Thankfully, we have everything we need to write one.</p>
<p>The <code>findLimit</code> function captures and restores the total, so that we’ll play nicely with out functions that work with the <code>Adder</code> monad, and calls out to a helper function to actually find the limit:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findLimit ::</span> <span class="dt">Adder</span> <span class="dt">Int</span>
<span class="co">-- or if we want to be more general:</span>
<span class="co">--   findLimit :: Monad m =&gt; AdderT m Int</span>
findLimit <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- capture the old count</span>
  t <span class="ot">&lt;-</span> total
  <span class="co">-- clear the count</span>
  clear
  <span class="co">-- seek out the limit</span>
  r <span class="ot">&lt;-</span> execStateT findLimit&#39; <span class="dv">0</span>
  <span class="co">-- restore the old count</span>
  clear
  _ <span class="ot">&lt;-</span> add t
  <span class="co">-- return the result</span>
  return r</code></pre></div>
<p>As <code>Adder</code> is a monad, we can put it in a stack of monad transformers. In this case we use <code>StateT</code> to keep track of how much we’ve added to the total so far.</p>
<p>We have <code>execStateT findLimit' 0</code> in <code>findLimit</code> which will start the state at <code>0</code> and return whatever it ends up at when we finish with <code>findLimit'</code>, so we just need to increment both our total and our state until we overflow and all should be well.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">findLimit&#39; ::</span> <span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">Adder</span> ()
findLimit&#39; <span class="fu">=</span> <span class="kw">do</span>
  <span class="co">-- add 1 to the total</span>
  r <span class="ot">&lt;-</span> lift <span class="fu">$</span> add <span class="dv">1</span>
  <span class="co">-- check for overflow</span>
  when r <span class="fu">$</span> <span class="kw">do</span>
    <span class="co">-- if no overflow, add to our state counter ...</span>
    modify (<span class="fu">+</span> <span class="dv">1</span>)
    <span class="co">-- and continue</span>
    findLimit&#39;</code></pre></div>
<h3 id="ad-hoc-interpretation-of-our-free-monad">Ad-hoc interpretation of our free monad</h3>
<p>At this point, some folks would build an interpreter for their DSL that may look a little like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpret ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">AdderT</span> m r <span class="ot">-&gt;</span> m r
interpret limit count a <span class="fu">=</span> <span class="kw">do</span>
  mr <span class="ot">&lt;-</span> runFreeT a
  <span class="kw">case</span> mr <span class="kw">of</span>
    <span class="dt">Pure</span> r <span class="ot">-&gt;</span> return r
    <span class="dt">Free</span> (<span class="dt">Add</span> x k) <span class="ot">-&gt;</span>
      <span class="kw">let</span>
        count&#39; <span class="fu">=</span> x <span class="fu">+</span> count
        test <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit
        next <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count
      <span class="kw">in</span>
        interpret limit next (k test)
    <span class="dt">Free</span> (<span class="dt">Clear</span> k) <span class="ot">-&gt;</span>
      interpret limit <span class="dv">0</span> k
    <span class="dt">Free</span> (<span class="dt">Total</span> k) <span class="ot">-&gt;</span>
      interpret limit count (k count)</code></pre></div>
<p>We can encapsulate the recursion with things like <code>iter</code>, <code>iterT</code> and <code>iterTM</code>, and I’ve written <code>iterTTM</code> in the accompanying to show how that works in this case.</p>
<p>That’s fine, but I think we can do better.</p>
<h2 id="cofree">Cofree</h2>
<p>If you’re not familiar with comonads, I highly recommend another of Gabriel Gonzalez’s <a href="http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html">posts</a>. I’ve also written <a href="/posts/comonads.html">this</a> based on the rushed explanation I gave in my talk, but you should read Gabriel’s post instead.</p>
<p>We won’t need much familiarity with comonads now, but it’ll probably come in handy for subsequent posts.</p>
<p>Where <code>Free</code> was a sum type, <code>Cofree</code> is the product type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="fu">=</span> a <span class="fu">:&lt;</span> f (<span class="dt">Cofree</span> f a)</code></pre></div>
<p>You can also view this as a kind of tree, except we’ve got values at the branching points instead of at the leaves. This make <code>Cofree</code> handy for working with interpreters that run forever, since we can lazily build an infinite <code>Cofree</code> and then travel through the tree as we like.</p>
<p>Again, if <code>f</code> is a functor then we have a <code>Comonad</code> for <code>Cofree f</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Comonad</span> (<span class="dt">Cofree</span> f)
  extract (a <span class="fu">:&lt;</span> _) <span class="fu">=</span> a
  duplicate c<span class="fu">@</span>(_ <span class="fu">:&lt;</span> fs) <span class="fu">=</span> <span class="dt">Cofree</span> c (fmap duplicate fs)</code></pre></div>
<h3 id="an-interpreter-for-our-dsl">An interpreter for our DSL</h3>
<p>We’re now specifying an interpreter rather than a DSL. At any point in time, the interpreter needs to be able to handle <em>any</em> of our DSL actions. Where we had a sum type of three actions in the DSL, we now have a product type of three handlers in the interpreter.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">CoAdderF</span> k <span class="fu">=</span> <span class="dt">CoAdderF</span> {
<span class="ot">    addH   ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, k)
  ,<span class="ot"> clearH ::</span> k
  ,<span class="ot"> totalH ::</span> (<span class="dt">Int</span>, k)
  }</code></pre></div>
<p>The type parameter <code>k</code> represents the handlers that we’ll be using once we’ve interpreted the next action.</p>
<p>In order to make a <code>Comonad</code> out of this we need a <code>Functor</code> instance. We could just use <code>DeriveFunctor</code>, but it’s easy enough to write out here:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">CoAdderF</span> <span class="kw">where</span>
  fmap f (<span class="dt">CoAdderF</span> a c t) <span class="fu">=</span> <span class="dt">CoAdderF</span>
    (fmap (fmap f) a)
    (f c)
    (fmap f t)</code></pre></div>
<h3 id="providing-an-interpretation-for-our-interpreter">Providing an interpretation for our interpreter</h3>
<p>We can use <code>coiter</code> to lazily build up a <code>Cofree</code> value.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coiter ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Cofree</span> f a</code></pre></div>
<p>We just need a seed value and a function which will take us from one level to the next.</p>
<p>This will expand</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">coiter next start</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">start <span class="fu">:&lt;</span> coiter next <span class="fu">&lt;$&gt;</span> next start</code></pre></div>
<p>to</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">start <span class="fu">:&lt;</span> next start <span class="fu">:&lt;</span> coiter next <span class="fu">&lt;$&gt;</span> (next <span class="fu">.</span> next <span class="fu">$</span> start)</code></pre></div>
<p>and so on.</p>
<p>So armed, we begin the definition of our interpreter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Limit</span> <span class="fu">=</span> <span class="dt">Int</span>
<span class="kw">type</span> <span class="dt">Count</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">CoAdder</span> a <span class="fu">=</span> <span class="dt">Cofree</span> <span class="dt">CoAdderF</span> a

<span class="ot">mkCoAdder ::</span> <span class="dt">Limit</span> <span class="ot">-&gt;</span> <span class="dt">Count</span> <span class="ot">-&gt;</span> <span class="dt">CoAdder</span> (<span class="dt">Limit</span>, <span class="dt">Count</span>)
mkCoAdder limit count <span class="fu">=</span> coiter next start
  <span class="kw">where</span>
    next w <span class="fu">=</span> <span class="dt">CoAdderF</span> (coAdd w) (coClear w) (coTotal w)
    start <span class="fu">=</span> (limit, count)</code></pre></div>
<p>At this point we just need to define <code>coAdd</code>, <code>coClear</code> and <code>coTotal</code>.</p>
<p>Clearing the current total is pretty self explanatory:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coClear ::</span> (<span class="dt">Limit</span>, <span class="dt">Count</span>) <span class="ot">-&gt;</span> (<span class="dt">Limit</span>, <span class="dt">Count</span>)
coClear (limit, count) <span class="fu">=</span> (limit, <span class="dv">0</span>)</code></pre></div>
<p>As is querying for the current total:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coTotal ::</span> (<span class="dt">Limit</span>, <span class="dt">Count</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, (<span class="dt">Limit</span>, <span class="dt">Count</span>))
coTotal (limit, count) <span class="fu">=</span> (count, (limit, count))</code></pre></div>
<p>There are a few more moving parts involved when adding to the total:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">coAdd ::</span> (<span class="dt">Limit</span>, <span class="dt">Count</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, (<span class="dt">Limit</span>, <span class="dt">Count</span>))
coAdd (limit, count) x <span class="fu">=</span> (test, (limit, next))
  <span class="kw">where</span>
    count&#39; <span class="fu">=</span> count <span class="fu">+</span> x                        <span class="co">-- 1</span>
    test <span class="fu">=</span> count&#39; <span class="fu">&lt;=</span> limit                    <span class="co">-- 2</span>
    next <span class="fu">=</span> <span class="kw">if</span> test <span class="kw">then</span> count&#39; <span class="kw">else</span> count     <span class="co">-- 3</span></code></pre></div>
<p>At (1) we add the incoming <code>x</code> to the current total <code>count</code>, to get the (potential) new total <code>count'</code>.</p>
<p>At (2) we test to see if this new total is beyond our internal limit. This is bound as <code>test</code>, which is part of what <code>coAdd</code> returns</p>
<p>At (3) we determine the new total. If <code>count'</code> is beneath the <code>limit</code> then we should update the total, otherwise we leave it where it was.</p>
<p>Now we an interpreter that is independent from our DSL. Just like with our DSL, we can build on things on top of our interpreter, we can destruct the <code>Cofree</code> structure in order to match it to a DSL, and we do that for different DSLs for different purposes.</p>
<h2 id="combining-the-free-and-cofree">Combining the free and cofree</h2>
<p>There is a handy way to bring <code>Free</code> and <code>Cofree</code> together, which has previously been discussed by <a href="http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/%7D%7Bhttp://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/">Ed Kmett</a> and <a href="http://blog.sigfpe.com/2014/05/cofree-meets-free.html%7D%7Bhttp://blog.sigfpe.com/2014/05/cofree-meets-free.html">Dan Piponi</a>.</p>
<p>I’ll be using the terminology - and some of the instances - from Dans post.</p>
<p>We start by introducing a new typeclass, <code>Pairing</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> g) <span class="ot">=&gt;</span> <span class="dt">Pairing</span> f g <span class="kw">where</span>
<span class="ot">    pair ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g b <span class="ot">-&gt;</span> r</code></pre></div>
<p>The simplest example is with the <code>Identity</code> functor:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">Identity</span> <span class="dt">Identity</span> <span class="kw">where</span>
  pair f (<span class="dt">Identity</span> a) (<span class="dt">Identity</span> b) <span class="fu">=</span> f a b</code></pre></div>
<p>We can step it up a notch:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> ((<span class="ot">-&gt;</span>) a) ((,) a) <span class="kw">where</span>
  pair p f <span class="fu">=</span> uncurry (p <span class="fu">.</span> f)

<span class="kw">instance</span> <span class="dt">Pairing</span> ((,) a) ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
  pair p f g <span class="fu">=</span> p (snd f) (g (fst f))</code></pre></div>
<p>Although we can save some time on the second version:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> ((<span class="ot">-&gt;</span>) a) ((,) a) <span class="kw">where</span>
  pair p f <span class="fu">=</span> uncurry (p <span class="fu">.</span> f)

<span class="kw">instance</span> <span class="dt">Pairing</span> ((,) a) ((<span class="ot">-&gt;</span>) a) <span class="kw">where</span>
  pair p f g <span class="fu">=</span> pair (flip p) g f</code></pre></div>
<p>So what does this buy us? Given a <code>Pairing</code> between the underlying functors <code>f</code> and <code>g</code>, we can create a <code>Pairing</code> between <code>Cofree f</code> and <code>Free g</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> f g <span class="ot">=&gt;</span> <span class="dt">Pairing</span> (<span class="dt">Cofree</span> f) (<span class="dt">Free</span> g) <span class="kw">where</span>
  pair p (a <span class="fu">:&lt;</span> _ ) (<span class="dt">Pure</span> x)  <span class="fu">=</span> p a x
  pair p (_ <span class="fu">:&lt;</span> fs) (<span class="dt">Free</span> gs) <span class="fu">=</span> pair (pair p) fs gs</code></pre></div>
<p>The pairing for our underlying functors isn’t hard to do - mostly since we built the <code>CoAdderF</code> type with pairing in mind.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">CoAdderF</span> <span class="dt">AdderF</span> <span class="kw">where</span>
  pair f (<span class="dt">CoAdderF</span> a _ _) (<span class="dt">Add</span> x k) <span class="fu">=</span> pair f (a x) k
  pair f (<span class="dt">CoAdderF</span> _ c _) (<span class="dt">Clear</span> k) <span class="fu">=</span> f c k
  pair f (<span class="dt">CoAdderF</span> _ _ t) (<span class="dt">Total</span> k) <span class="fu">=</span> pair f t k</code></pre></div>
<p>Note that we’re using the <code>Pairing</code> instance for <code>(-&gt;)</code> and <code>(,)</code> in the case of <code>Total</code>, and could have done something similar for <code>Add</code> if we’d tupled its arguments.</p>
<h3 id="making-use-of-the-pairing">Making use of the pairing</h3>
<p>Now let us make use of all of this.</p>
<p>Given an arbitrary interpreter, we can find its limit:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runLimit ::</span> <span class="dt">CoAdder</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
runLimit w <span class="fu">=</span> pair (\_ b <span class="ot">-&gt;</span> b) w findLimit</code></pre></div>
<p>such that this should hold for arbitrary <code>x</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">testLimit ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
testLimit x <span class="fu">=</span> runLimit (mkCoAdder x <span class="dv">0</span>) <span class="fu">==</span> x</code></pre></div>
<p>The <code>Pairing</code> is what allows us to define our DSL and interpreter independently from one another while still being able to bring them together like this.</p>
<h3 id="pairing-the-functors-under-dsls-and-interpreters">Pairing the functors under DSLs and Interpreters</h3>
<p>In general, if we have a sum type for our DSL then we’ll have a product type for our interpreter.</p>
<p>If we have a functor for a DSL which is a sum of commands:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DslF</span> k <span class="fu">=</span>
    <span class="dt">Sum_1</span> k
  <span class="fu">|</span> <span class="dt">Sum_2</span> k
  <span class="fu">|</span> <span class="fu">...</span>
  <span class="fu">|</span> <span class="dt">Sum_n</span> k</code></pre></div>
<p>then we’ll start build the functor for an interpreter as a product of handlers like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">InterpreterF</span> k <span class="fu">=</span> <span class="dt">InterpreterF</span> {
    <span class="dt">Product_1</span> k
  , <span class="dt">Product_2</span> k
  , <span class="fu">...</span>
  , <span class="dt">Product_n</span> k
  }</code></pre></div>
<p>and the pairing will look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">InterpreterF</span> <span class="dt">DslF</span> <span class="kw">where</span>
  pair f (<span class="dt">InterpreterF</span> j _ <span class="fu">...</span> _) (<span class="dt">Sum_1</span> k) <span class="fu">=</span> f j k
  pair f (<span class="dt">InterpreterF</span> _ j <span class="fu">...</span> _) (<span class="dt">Sum_2</span> k) <span class="fu">=</span> f j k
  <span class="fu">...</span>
  pair f (<span class="dt">InterpreterF</span> _ _ <span class="fu">...</span> j) (<span class="dt">Sum_n</span> k) <span class="fu">=</span> f j k</code></pre></div>
<p>There is a little more going on if our commands have arguments and return results.</p>
<p>Say we have a functor for DSL like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">DslF</span> k <span class="fu">=</span>
    <span class="dt">Sum_1</span> <span class="dt">Arg_1</span> <span class="dt">Arg_2</span> <span class="fu">...</span> <span class="dt">Arg_n</span> ((<span class="dt">Res_1</span>, <span class="dt">Res_2</span>, <span class="fu">...</span>, <span class="dt">Res_m</span>) <span class="ot">-&gt;</span> k)
  <span class="fu">|</span> <span class="dt">Sum_2</span> k</code></pre></div>
<p>This will result in this functor for the paired interpreter</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">InterpreterF</span> k <span class="fu">=</span> <span class="dt">InterpreterF</span> {
    <span class="dt">Product_1</span> ((<span class="dt">Arg_1</span>, <span class="dt">Arg_2</span>, <span class="fu">...</span>, <span class="dt">Arg_n</span>) <span class="ot">-&gt;</span> (<span class="dt">Res_1</span>, <span class="dt">Res_2</span>, <span class="fu">...</span>, <span class="dt">Res_m</span>, k))
  , <span class="dt">Product_2</span> k
  }</code></pre></div>
<p>with the following pairing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Pairing</span> <span class="dt">InterpreterF</span> <span class="dt">DslF</span> <span class="kw">where</span>
  pair f (<span class="dt">InterpreterF</span> j _) (<span class="dt">Sum1</span> a_1 a_2 <span class="fu">...</span> a_n k) <span class="fu">=</span>
    <span class="kw">let</span>
      (r_1, r_2, <span class="fu">...</span>, r_m, j&#39;) <span class="fu">=</span> j (a_1, a_2, <span class="fu">...</span>, a_n)
      k&#39;                       <span class="fu">=</span> k (r_1, r_2, <span class="fu">...</span>, r_m)
    <span class="kw">in</span>
      f j&#39; k&#39;
  pair f (<span class="dt">InterpreterF</span> _ j) (<span class="dt">Sum2</span> k) <span class="fu">=</span> f j k</code></pre></div>
<p>You can do funkier things than this, but that should be enough to get you started.</p>
<h2 id="where-to-from-here">Where to from here</h2>
<p>I have a lot I’d like to explore and write about, but the next few topics will be based on the things I already partly covered in the talk that this is based on.</p>
<p>The current version of our interpreter is manually handing both environment and state. We can clean this up by using <a href="/posts/monad_transformers_and_comonad_transformers.html">comonad transformers</a>. This turns out to be pretty similar to working with monad transformers, down to the fact that we can use the transformers in either <code>transformers</code> or <code>mtl</code> style.</p>
<p>We can break the DSL down into independent parts using <a href="/posts/coproducts_for_free_and_products_for_cofree.html">coproducts</a>, as covered in <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.4131">Data types a la carte</a>. In addition to this, we can factor out the independent parts of the interpreter using products.</p>
<p>We can bring some other effects into the mix. This will allows us to interact with our interpreter from the console, and to connect our DSL to our interpreter over the network.</p>
<p>There’s a lot more in the queue, but comonad transformers, coproducts/products, and working with additional effects should make a pretty good start.</p>
<p><a href="http://www.reddit.com/r/haskell/comments/385b3k/free_and_cofree/">Questions? Comments?</a></p>]]></description>
    <pubDate>Mon, 01 Jun 2015 12:00:00 UT</pubDate>
    <guid>http://dlaing.org/cofun/posts/free_and_cofree.html</guid>
    <dc:creator>Dave Laing</dc:creator>
</item>

    </channel>
</rss>
